module src/test

import test
import scanner
import src/lib/testUtils
import src/lib/lexer
import src/lib/parser
import src/lib/sugar
import src/lib/tokens
import src/lib/ast
import src/lib/errors
import src/lib/effects

def main() = mainSuite("lib") {

  def collectTokens(acc: List[Token]) { next: => Token}: List[Token] = {
    val t = next()
    t.kind match {
      case EOF() => acc.reverse
      case _ => collectTokens(Cons(t, acc)) { next } 
    }
  }

  def fullLexerHandler(input: String, assertLexerError: Bool) { prog: => Unit / { Lexer[Token]}} = {
    
    if (assertLexerError) {
      with feed(input)
      with scanner[Char]
      with scanWithPos
      with on[LexerError].assertThrown
      with lexer
      prog()
    } else {
      with feed(input)
      with scanner[Char]
      with scanWithPos
      with on[LexerError].panic
      with lexer
      prog()
    }
  } 


  test("lexer produces tokens and skips whitespace") {
    val input =
    "val x = 10\n" ++
    "if (x >= 10) {\n" ++
    "  x = x + 1\n" ++
    "} else {\n" ++
    "  x = x + 2\n" ++
    "}"

    val expected = [Token(Val(), Position(1, 1)), Token(LowerIdentifier("x"), Position(1, 5)), Token(Assign(), Position(1, 7)), Token(Number(10), Position(1, 9)), Token(If(), Position(2, 1)), Token(LParen(), Position(2, 4)), Token(LowerIdentifier("x"), Position(2, 5)), Token(GreaterEqual(), Position(2, 7)), Token(Number(10), Position(2, 10)), Token(RParen(), Position(2, 12)), Token(LBrace(), Position(2, 14)), Token(LowerIdentifier("x"), Position(3, 3)), Token(Assign(), Position(3, 5)), Token(LowerIdentifier("x"), Position(3, 7)), Token(Plus(), Position(3, 9)), Token(Number(1), Position(3, 11)), Token(RBrace(), Position(4, 1)), Token(Else(), Position(4, 3)), Token(LBrace(), Position(4, 8)), Token(LowerIdentifier("x"), Position(5, 3)), Token(Assign(), Position(5, 5)), Token(LowerIdentifier("x"), Position(5, 7)), Token(Plus(), Position(5, 9)), Token(Number(2), Position(5, 11)), Token(RBrace(), Position(6, 1))]

    with fullLexerHandler(input, false) 
    val tokens = collectTokens(Nil()) { do next() }
    
    assertEqual(tokens, expected)
  }

  test("lexer distinguishes correctly between LowerIdentifier and UpperIdentifier") {
    val input = "val x: Int = 2"

    val expected = [Token(Val(), Position(1, 1)), Token(LowerIdentifier("x"), Position(1, 5)), Token(Colon(), Position(1, 6)), Token(UpperIdentifier("Int"), Position(1, 8)), Token(Assign(), Position(1, 12)), Token(Number(2), Position(1, 14))]

    with fullLexerHandler(input, false)
    val tokens = collectTokens(Nil()) { do next() }
    assertEqual(tokens, expected)
  }

  test("lexer throws LexerError on unknown char") { 
    val input = "val x = 2;"

    with fullLexerHandler(input, true)
    val tokens = collectTokens(Nil()) { do next() }
  }

  test("lexer throws LexerError if an identifier starts with a number") {
    val input = "val 1x = 2"

    with fullLexerHandler(input, true)
    val tokens = collectTokens(Nil()) { do next() }
  }

  test("lexer recognizes logical operators (and, or, not)") {
    val inputs = ["and", "or", "not"]
    val expectedOutputs = [
      [Token(And(), Position(1, 1))],
      [Token(Or(), Position(1, 1))],
      [Token(Not(), Position(1, 1))]
    ]

    var iter = 0
    while (iter < inputs.size) {
      with on[OutOfBounds].panic
      with fullLexerHandler(inputs.get(iter), false)
      val tokens = collectTokens(Nil()) { do next() }
      assertEqual(tokens, expectedOutputs.get(iter))
      iter = iter + 1
    }
  }

  test("lexer recognizes complex expressions with logical operators") {
    val input = "val x = not (true and false) or (false or true and not false)"

    val expected = [
      Token(Val(), Position(1, 1)),
      Token(LowerIdentifier("x"), Position(1, 5)),
      Token(Assign(), Position(1, 7)),
      Token(Not(), Position(1, 9)),
      Token(LParen(), Position(1, 13)),
      Token(Boolean(true), Position(1, 14)),
      Token(And(), Position(1, 19)),
      Token(Boolean(false), Position(1, 23)),
      Token(RParen(), Position(1, 28)),
      Token(Or(), Position(1, 30)),
      Token(LParen(), Position(1, 33)),
      Token(Boolean(false), Position(1, 34)),
      Token(Or(), Position(1, 40)),
      Token(Boolean(true), Position(1, 43)),
      Token(And(), Position(1, 48)),
      Token(Not(), Position(1, 52)),
      Token(Boolean(false), Position(1, 56)),
      Token(RParen(), Position(1, 61))
    ]

    with fullLexerHandler(input, false)
    val tokens = collectTokens(Nil()) { do next() }
    assertEqual(tokens, expected)
  }

  test("parser parses variable declaration without type annotation (Int literal, Bool literal)") {
    val inputs = ["val x = 2", "val x = false"]
    val expectedOutputs = [
      [VariableDecl("x", None(), IntLiteral(2))], 
      [VariableDecl("x", None(), BoolLiteral(false))]
    ]
    var iter = 0

    while (iter < inputs.size) {
      with on[OutOfBounds].panic
      with feed(inputs.get(iter))
      with scanner[Char]
      with scanWithPos
      with on[LexerError].panic
      with lexer
      with on[ParseError].panic

      val obtained = parseProgram()

      assertEqual(obtained, expectedOutputs.get(iter))
      iter = iter + 1
    }
   
  }

  test("parser parses variable declaration with type annotation (Int literal, Bool literal)") {
    val inputs = ["val x: Int = 2", "val x: Bool = false"]
    val expectedOutputs = [
      [VariableDecl("x", Some(IntType()), IntLiteral(2))], 
      [VariableDecl("x", Some(BoolType()), BoolLiteral(false))]
    ]
    var iter = 0

    while (iter < inputs.size) {
      with on[OutOfBounds].panic
      with feed(inputs.get(iter))
      with scanner[Char]
      with scanWithPos
      with on[LexerError].panic
      with lexer
      with on[ParseError].panic

      val obtained = parseProgram()

      assertEqual(obtained, expectedOutputs.get(iter))
      iter = iter + 1
    }
  }

  test("parser parses binary math expressions (Add, Sub, Mult, Div)") {
    val inputs = ["2 + 2", "2 - 2", "2 * 2", "2 / 2"]

    val expectedOutputs = [
      [ExprStmt(AddExpr(IntLiteral(2), IntLiteral(2)))],
      [ExprStmt(SubExpr(IntLiteral(2), IntLiteral(2)))],
      [ExprStmt(MultExpr(IntLiteral(2), IntLiteral(2)))],
      [ExprStmt(DivExpr(IntLiteral(2), IntLiteral(2)))]
    ]

    var iter = 0
    while (iter < inputs.size) {
      with on[OutOfBounds].panic
      with feed(inputs.get(iter))
      with scanner[Char]
      with scanWithPos
      with on[LexerError].panic
      with lexer
      with on[ParseError].panic 
      
      val obtained = parseProgram()
     
      assertEqual(obtained, expectedOutputs.get(iter))
      iter = iter + 1
    }
  }

  test("parser parses binary compare expressions (Eq, Neq, Lt, Gt, LtE, GtE)") {
    val inputs = ["2 == 2", "2 != 2", "2 < 2", "2 > 2", "2 <= 2", "2 >= 2"]

    val expectedOutputs = [
      [ExprStmt(Eq(IntLiteral(2), IntLiteral(2)))],
      [ExprStmt(Neq(IntLiteral(2), IntLiteral(2)))],
      [ExprStmt(Lt(IntLiteral(2), IntLiteral(2)))],
      [ExprStmt(Gt(IntLiteral(2), IntLiteral(2)))],
      [ExprStmt(LtE(IntLiteral(2), IntLiteral(2)))],
      [ExprStmt(GtE(IntLiteral(2), IntLiteral(2)))]
    ]

    var iter = 0
    while (iter < inputs.size) {
      with on[OutOfBounds].panic
      with feed(inputs.get(iter))
      with scanner[Char]
      with scanWithPos
      with on[LexerError].panic
      with lexer
      with on[ParseError].panic 
      
      val obtained = parseProgram()
     
      assertEqual(obtained, expectedOutputs.get(iter))
      iter = iter + 1
    }
  }

  test("parser parses chained compare expressions (a < b < c)") {
    val inputs = ["2 < 3 < 4", "2 <= 3 <= 4", "4 > 3 > 2", "4 >= 3 >= 2", "2 == 3 == 4", "2 != 3 != 4", "2 < 3 > 4 == 5"]

    val expectedOutputs = [
      [ExprStmt(CompareChain(IntLiteral(2), Cons((Less(), IntLiteral(3)), Cons((Less(), IntLiteral(4)), Nil()))))],
      [ExprStmt(CompareChain(IntLiteral(2), Cons((LessEqual(), IntLiteral(3)), Cons((LessEqual(), IntLiteral(4)), Nil()))))],
      [ExprStmt(CompareChain(IntLiteral(4), Cons((Greater(), IntLiteral(3)), Cons((Greater(), IntLiteral(2)), Nil()))))],
      [ExprStmt(CompareChain(IntLiteral(4), Cons((GreaterEqual(), IntLiteral(3)), Cons((GreaterEqual(), IntLiteral(2)), Nil()))))],
      [ExprStmt(CompareChain(IntLiteral(2), Cons((Equal(), IntLiteral(3)), Cons((Equal(), IntLiteral(4)), Nil()))))],
      [ExprStmt(CompareChain(IntLiteral(2), Cons((NotEqual(), IntLiteral(3)), Cons((NotEqual(), IntLiteral(4)), Nil()))))],
      [ExprStmt(CompareChain(IntLiteral(2), Cons((Less(), IntLiteral(3)), Cons((Greater(), IntLiteral(4)), Cons((Equal(), IntLiteral(5)), Nil())))))]
    ]
    var iter = 0
    while (iter < inputs.size) {
      with on[OutOfBounds].panic
      with feed(inputs.get(iter))
      with scanner[Char]
      with scanWithPos
      with on[LexerError].panic
      with lexer
      with on[ParseError].panic 
      
      val obtained = parseProgram()
    
      assertEqual(obtained, expectedOutputs.get(iter))
      iter = iter + 1
    }
  }

  test("parser parses logical expressions (and, or, not)") {
    val inputs = [
      "true and false",
      "true or false",
      "not true",
      "not false",
      "true and false or true",
      "not (true or false) and true"
    ]

    val expectedOutputs = [
      [ExprStmt(AndExpr(BoolLiteral(true), BoolLiteral(false)))],
      [ExprStmt(OrExpr(BoolLiteral(true), BoolLiteral(false)))],
      [ExprStmt(NotExpr(BoolLiteral(true)))],
      [ExprStmt(NotExpr(BoolLiteral(false)))],
      [ExprStmt(OrExpr(AndExpr(BoolLiteral(true), BoolLiteral(false)), BoolLiteral(true)))],
      [ExprStmt(AndExpr(NotExpr(OrExpr(BoolLiteral(true), BoolLiteral(false))), BoolLiteral(true)))]
    ]

    var iter = 0
    while (iter < inputs.size) {
      with on[OutOfBounds].panic
      with feed(inputs.get(iter))
      with scanner[Char]
      with scanWithPos
      with on[LexerError].panic
      with lexer
      with on[ParseError].panic 
      
      val obtained = parseProgram()
     
      assertEqual(obtained, expectedOutputs.get(iter))
      iter = iter + 1
    }
  }

  test("parser parses if-expressions"){
    val input = "val x = if true then 1 else 0"

    val expected = [
      VariableDecl( "x", None(), IfExpr(BoolLiteral(true), IntLiteral(1), IntLiteral(0)))
    ]

    with on[OutOfBounds].panic
    with feed(input)
    with scanner[Char]
    with scanWithPos
    with on[LexerError].panic
    with lexer
    with on[ParseError].panic 

    val obtained = parseProgram()
   
    assertEqual(obtained, expected)
  }

  test("parser parses if-statement without else branch") {
    val input = "if (true) { 1 }"

    val expected = [
      IfStmt(
          BoolLiteral(true),
          [ExprStmt(IntLiteral(1))],
          Nil()
        )
    ]

    with on[OutOfBounds].panic
    with feed(input)
    with scanner[Char]
    with scanWithPos
    with on[LexerError].panic
    with lexer
    with on[ParseError].panic 

    val obtained = parseProgram()
   
    assertEqual(obtained, expected)
  }

  test("parser parses if-statement with logical conditions") {
    val input = "if (not false and true) { 1 } else { 0 }"

    val expected = [
      IfStmt(
          AndExpr(
            NotExpr(BoolLiteral(false)),
            BoolLiteral(true)),
          [ExprStmt(IntLiteral(1))],
          [ExprStmt(IntLiteral(0))]
        )
    ]

    with on[OutOfBounds].panic
    with feed(input)
    with scanner[Char]
    with scanWithPos
    with on[LexerError].panic
    with lexer
    with on[ParseError].panic 

    val obtained = parseProgram()
   
    assertEqual(obtained, expected)
  }

  test("parser parses complex program with variable declarations, if-statements, and expressions") {
    val input =
    "val x: Int = 10\n" ++
    "val y: Bool = true\n" ++
    "if (x >= 10 and not y) {\n" ++
    "  x + 1\n" ++
    "} else {\n" ++
    "  x - 1\n" ++
    "}"

    val expected = [
      VariableDecl("x", Some(IntType()), IntLiteral(10)),
      VariableDecl("y", Some(BoolType()), BoolLiteral(true)),
      IfStmt(
        AndExpr(
          GtE(Variable("x"), IntLiteral(10)),
          NotExpr(Variable("y"))
        ),
        [ExprStmt(AddExpr(Variable("x"), IntLiteral(1)))],
        [ExprStmt(SubExpr(Variable("x"), IntLiteral(1)))]
      )
    ]

    with on[OutOfBounds].panic
    with feed(input)
    with scanner[Char]
    with scanWithPos
    with on[LexerError].panic
    with lexer
    with on[ParseError].panic 

    val obtained = parseProgram()
   
    assertEqual(obtained, expected)
  }

  test("compare chains get desugared correctly") {
    val input = "val x = 2 < 3 < 4"

    val expected = [
      VariableDecl("x", None(), AndExpr(Lt(IntLiteral(2), IntLiteral(3)), Lt(IntLiteral(3), IntLiteral(4))))
    ]

    with on[OutOfBounds].panic
    with feed(input)
    with scanner[Char]
    with scanWithPos
    with on[LexerError].panic
    with lexer
    with on[ParseError].panic 

    val obtained = desugarProgram(parseProgram())
   
    assertEqual(obtained, expected)
  }
}