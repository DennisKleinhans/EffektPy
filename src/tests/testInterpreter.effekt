module src/tests/testInterpreter

import test
import src/lib/interpreter/eval
import src/lib/desugar/coreAst
import src/lib/utils/testUtils
import src/lib/utils/handlers
import src/lib/utils/errors
import src/lib/utils/coreTestUtils
import src/lib/utils/helpers
import src/lib/lexer/position
import src/lib/interpreter/values

def main() = mainSuite("interpreter") {

  val mockedPos = Position(1, 1)

  test("eval simple arithmetic") {
    val progs = [
      [cExpr(cAdd(cLit(10), cLit(20)))],
      [cExpr(cSub(cLit(30), cLit(5)))],
      [cExpr(cMult(cLit(4), cLit(5)))],
      [cExpr(cDiv(cLit(20), cLit(4)))],
      [cExpr(cAdd(cMult(cLit(2), cLit(3)), cLit(5)))],
      [cExpr(cSub(cDiv(cLit(50), cLit(2)), cLit(5)))]
    ]

    val expected = [
      VInt(30),
      VInt(25),
      VInt(20),
      VInt(5),
      VInt(11),
      VInt(20)
    ]
    var iter = 0

    while(iter < progs.size) {
      with on[RuntimeError].panic
      with on[OutOfBounds].panic
      with mockGetPos 
      with mockInspector[Unit, Address]

      val result = evalProgram(progs.get(iter))
      assertTrue(result.equal(expected.get(iter)))
      iter = iter + 1
    } 
  }

  test("eval equality and inequality") {
    val prog1 = cExpr(
      cEq(
        cLit(10),
        cLit(10)
      )
    )

    val prog2 = cExpr(
      cNeq(
        cLit(true),
        cLit(false)
      )
    )

    with on[RuntimeError].panic
    with mockGetPos 
    with mockInspector[Unit, Address]

    val result1 = evalProgram([prog1])
    assertTrue(result1.equal(VBool(true)))

    val result2 = evalProgram([prog2])
    assertTrue(result2.equal(VBool(true)))
  }

  test("eval comparison operators") {
    val progs = [
      [cExpr(cLt(cLit(15), cLit(20)))],
      [cExpr(cGt(cLit(25), cLit(10)))],
      [cExpr(cLtE(cLit(10), cLit(10)))],
      [cExpr(cGtE(cLit(30), cLit(40)))]
    ]

    val expected = [VBool(true), VBool(true), VBool(true), VBool(false)]
    var iter = 0
    while(iter < progs.size) {
      with on[RuntimeError].panic
      with on [OutOfBounds].panic
      with mockGetPos 
      with mockInspector[Unit, Address]

      val result = evalProgram(progs.get(iter))
      assertTrue(result.equal(expected.get(iter)))
      iter = iter + 1
    }
  }

  test("eval simple if expressions") {
    val prog1 = cExpr(
      cIf(
        cLit(true),
        cLit(10),
        cLit(20)
      )
    )

    val prog2 = cExpr(
      cIf(
        cLit(false),
        cLit(10),
        cLit(20)
      )
    )

    with on[RuntimeError].panic
    with mockGetPos 
    with mockInspector[Unit, Address]

    val result1 = evalProgram([prog1])
    assertTrue(result1.equal(VInt(10)))

    val result2 = evalProgram([prog2])
    assertTrue(result2.equal(VInt(20)))
  }

  test("eval if expression with comparison") {
    val prog = cExpr(
      cIf(
        cOr(
          cAnd(
            cLit(true),
            cLit(false)
          ),
          cLit(true)
        ),
        cLit(42),
        cLit(0)
      )
    )

    with on[RuntimeError].panic
    with mockGetPos 
    with mockInspector[Unit, Address]

    val result = evalProgram([prog])
    assertTrue(result.equal(VInt(42)))
  }

  test("eval division by zero raises RuntimeError") {
    val prog = cExpr(
      cDiv(
        cLit(10),
        cLit(0)
      )
    )

    with mockGetPos 
    with mockInspector[Unit, Address]
    with assertThrows[RuntimeError]
    evalProgram([prog])
    ()
  }

  test("eval if statement") {
    val prog = [ 
      cVar("x", None(), cLit(0)),
      cIf(
        cLit(true),
        Block([
          cAssign("x", cLit(10))
        ], None()),
        Block([
          cAssign("x", cLit(20))
        ], None())
      ),
      cExpr(cV("x"))
    ]

    with on[RuntimeError].panic
    with mockGetPos 
    with mockInspector[Unit, Address]

    val result = evalProgram(prog)
    assertTrue(result.equal(VInt(10)))
  }

  test("eval nested if expressions") {
    val prog = cExpr(
      cIf(
        cLit(false),
        cLit(1),
        cIf(
          cLit(true),
          cLit(2),
          cLit(3)
        )
      )
    )

    with on[RuntimeError].panic
    with mockGetPos 
    with mockInspector[Unit, Address]

    val result = evalProgram([prog])
    assertTrue(result.equal(VInt(2)))
  }

  test("nested if statements") {
    val prog = [
      cVar("x", None(), cLit(0)),
      cIf(
        cLit(false),
        Block([
          cAssign("x", cLit(10))
        ], None()),
        Block([
          cIf(
            cLit(true),
            Block([
              cAssign("x", cLit(20))
            ], None()),
            Block([
              cAssign("x", cLit(30))
            ], None())
          )
        ], None())
      ),
      cExpr(cV("x"))
    ]

    with on[RuntimeError].panic
    with mockGetPos 
    with mockInspector[Unit, Address]

    val result = evalProgram(prog)
    assertTrue(result.equal(VInt(20)))
  }

  test("eval complex program") {
    val prog = [
      cVal("a", None(), cLit(10)),
      cVar("b", None(), cLit(20)),
      cAssign("b", cAdd(cV("a"), cLit(5))),
      cIf(cLt(cV("b"), cV("a")),
        Block([
          cAssign("b", cMult(cV("b"), cLit(2)))
        ], None()),
        Block([
          cAssign("b", cSub(cV("b"), cLit(5))),
          cVal("c", None(), cDiv(cV("b"), cLit(2))),
          cAssign("b", cIf(cGtE(cAdd(cV("b"), cV("c")), cLit(30)),
            cLit(100),
            cLit(50)
          ))
        ], None())
      ),
      cExpr(cV("b"))
    ]

    with on[RuntimeError].panic
    with mockGetPos 
    with mockInspector[Unit, Address]

    val result = evalProgram(prog)
    assertTrue(result.equal(VInt(50)))
  }

  test("while statement: increment counter") {
    val prog = [
      cVar("x", None(), cLit(0)),
      cWhile(
        cLt(cV("x"), cLit(5)),
        Block([
          cAssign("x", cAdd(cV("x"), cLit(1)))
        ], None())
      ),
      cExpr(cV("x"))
    ]

    with on[RuntimeError].panic
    with mockGetPos 
    with mockInspector[Unit, Address]

    val result = evalProgram(prog)
    assertTrue(result.equal(VInt(5)))
  }

  test("while statement: block does not execute when condition is false") {
    val prog = [
      cVar("x", None(), cLit(0)),
      cWhile(
        cLt(cV("x"), cLit(0)),
        Block([
          cAssign("x", cAdd(cV("x"), cLit(1)))
        ], None())
      ),
      cExpr(cV("x"))
    ]

    with on[RuntimeError].panic
    with mockGetPos 
    with mockInspector[Unit, Address]

    val result = evalProgram(prog)
    assertTrue(result.equal(VInt(0)))
  }

  test("break statement leaves the while loop") {
    val prog = [
      cVar("x", None(), cLit(0)),
      cWhile(
        cLt(cV("x"), cLit(5)),
        Block([
          cAssign("x", cAdd(cV("x"), cLit(1))),
          cIf(
            cEq(cV("x"), cLit(2)),
            Block([
              cBreak()
            ], None()),
          Block(Nil(), None())
          )
        ], None())
      ),
      cExpr(cV("x"))
    ] 

    with on[RuntimeError].panic
    with mockGetPos 
    with mockInspector[Unit, Address]
    val result = evalProgram(prog)

    assertTrue(result.equal(VInt(2)))
  }

  test("continue statement skips to next iteration") {
    val prog = [
      cVar("x", None(), cLit(0)),
      cVar("y", None(), cLit(0)),
      cWhile(
        cLt(cV("x"), cLit(5)),
        Block([
          cAssign("x", cAdd(cV("x"), cLit(1))),
          cIf(
            cEq(cV("x"), cLit(2)),
            Block([
              cContinue()
            ], None()),
          Block(Nil(), None())
          ),
          cAssign("y", cAdd(cV("y"), cLit(1)))
        ], None())
      ),
      cExpr(cV("y"))
    ] 

    with on[RuntimeError].panic
    with mockGetPos 
    with mockInspector[Unit, Address]
    val result = evalProgram(prog)

    assertTrue(result.equal(VInt(4)))
  }

  test("identity function") {
    val prog = [
      cVal("id", None(), cFun([Parameter("x", None(), None())], None(), Block(Nil(), Some(cV("x"))))),
      cExpr(cCall(cV("id"), [Argument(None(), cLit(42))]))
    ]

    with on[RuntimeError].panic
    with mockGetPos 
    with mockInspector[Unit, Address]
    val result = evalProgram(prog)

    assertTrue(result.equal(VInt(42)))
  }

  test("function with multiple parameters") {
    val prog = [
      cVal("add", None(), cFun(
        [Parameter("x", None(), None()), Parameter("y", None(), None())],
        None(),
        Block(Nil(), Some(cAdd(cV("x"), cV("y"))))
      )),
      cExpr(cCall(cV("add"), [Argument(None(), cLit(10)), Argument(None(), cLit(20))]))
    ]

    with on[RuntimeError].panic
    with mockGetPos 
    with mockInspector[Unit, Address]
    val result = evalProgram(prog)

    assertTrue(result.equal(VInt(30)))
  }

  test("function with named arguments") {
    val prog = [
      cVal("mul", None(), cFun(
        [Parameter("a", None(), None()), Parameter("b", None(), None())],
        None(),
        Block(Nil(), Some(cMult(cV("a"), cV("b"))))
      )),
      cExpr(cCall(cV("mul"), [Argument(Some("b"), cLit(5)), Argument(Some("a"), cLit(4))]))
    ]

    with on[RuntimeError].panic
    with mockGetPos 
    with mockInspector[Unit, Address]
    val result = evalProgram(prog)

    assertTrue(result.equal(VInt(20)))
  }

  test("function with mixed named and positional arguments") {
    val prog = [
      cVal("calc", None(), cFun(
        [Parameter("x", None(), None()), Parameter("y", None(), None()), Parameter("z", None(), None())],
        None(),
        Block(Nil(), Some(cAdd(cMult(cV("x"), cV("y")), cV("z"))))
      )),
      cExpr(cCall(cV("calc"), [Argument(None(), cLit(2)), Argument(Some("z"), cLit(10)), Argument(Some("y"), cLit(3))]))
    ]

    with on[RuntimeError].panic
    with mockGetPos 
    with mockInspector[Unit, Address]
    val result = evalProgram(prog)

    assertTrue(result.equal(VInt(16)))
  }

  test("variable shadowing in function parameter") {
    val prog = [
      cVal("x", None(), cLit(100)),
      cVal("shadow", None(), cFun(
        [Parameter("x", None(), None())],
        None(),
        Block(Nil(), Some(cV("x")))
      )),
      cExpr(cCall(cV("shadow"), [Argument(None(), cLit(42))]))
    ]

    with on[RuntimeError].panic
    with mockGetPos 
    with mockInspector[Unit, Address]
    val result = evalProgram(prog)

    assertTrue(result.equal(VInt(42)))
  }

  test("function parameter shadows outer variable in nested block") {
    val prog = [
      cVal("x", None(), cLit(100)),
      cVal("f", None(), cFun(
        [Parameter("x", None(), None())],
        None(),
        Block(Nil(), Some(cAdd(cV("x"), cLit(5))))
      )),
      cExpr(cCall(cV("f"), [Argument(None(), cLit(10))]))
    ]

    with on[RuntimeError].panic
    with mockGetPos 
    with mockInspector[Unit, Address]
    val result = evalProgram(prog)

    assertTrue(result.equal(VInt(15)))
  }

  test("nested function definition") {
    val prog = [
      cVal("outer", None(), cFun(
        [Parameter("x", None(), None())],
        None(),
        Block([
          cVal("inner", None(), cFun(
            [Parameter("y", None(), None())],
            None(),
            Block(Nil(), Some(cAdd(cV("x"), cV("y"))))
          ))
        ], Some(cCall(cV("inner"), [Argument(None(), cLit(20))])))
      )),
      cExpr(cCall(cV("outer"), [Argument(None(), cLit(10))]))
    ]

    with on[RuntimeError].panic
    with mockGetPos 
    with mockInspector[Unit, Address]
    val result = evalProgram(prog)

    assertTrue(result.equal(VInt(30)))
  }

  test("nested function with closure over multiple parameters") {
    val prog = [
      cVal("make_adder", None(), cFun(
        [Parameter("a", None(), None()), Parameter("b", None(), None())],
        None(),
        Block([
          cVal("add_third", None(), cFun(
            [Parameter("c", None(), None())],
            None(),
            Block(Nil(), Some(cAdd(cAdd(cV("a"), cV("b")), cV("c"))))
          ))
        ], Some(cCall(cV("add_third"), [Argument(None(), cLit(5))])))
      )),
      cExpr(cCall(cV("make_adder"), [Argument(None(), cLit(10)), Argument(None(), cLit(20))]))
    ]

    with on[RuntimeError].panic
    with mockGetPos 
    with mockInspector[Unit, Address]
    val result = evalProgram(prog)

    assertTrue(result.equal(VInt(35)))
  }

  test("function returning a function (currying)") {
    val prog = [
      cVal("curry_add", None(), cFun(
        [Parameter("x", None(), None())],
        None(),
        Block(Nil(), Some(cFun(
          [Parameter("y", None(), None())],
          None(),
          Block(Nil(), Some(cAdd(cV("x"), cV("y"))))
        )))
      )),
      cVal("add5", None(), cCall(cV("curry_add"), [Argument(None(), cLit(5))])),
      cExpr(cCall(cV("add5"), [Argument(None(), cLit(10))]))
    ]

    with on[RuntimeError].panic
    with mockGetPos 
    with mockInspector[Unit, Address]
    val result = evalProgram(prog)

    assertTrue(result.equal(VInt(15)))
  }

  test("parameter shadowing with multiple nested functions") {
    val prog = [
      cVal("x", None(), cLit(1)),
      cVal("f1", None(), cFun(
        [Parameter("x", None(), None())],
        None(),
        Block([
          cVal("f2", None(), cFun(
            [Parameter("x", None(), None())],
            None(),
            Block(Nil(), Some(cV("x")))
          ))
        ], Some(cCall(cV("f2"), [Argument(None(), cLit(3))])))
      )),
      cExpr(cCall(cV("f1"), [Argument(None(), cLit(2))]))
    ]

    with on[RuntimeError].panic
    with mockGetPos 
    with mockInspector[Unit, Address]
    val result = evalProgram(prog)

    assertTrue(result.equal(VInt(3)))
  }

  test("function accessing outer scope without shadowing") {
    val prog = [
      cVal("x", None(), cLit(100)),
      cVal("y", None(), cLit(50)),
      cVal("f", None(), cFun(
        [Parameter("z", None(), None())],
        None(),
        Block(Nil(), Some(cAdd(cAdd(cV("x"), cV("y")), cV("z"))))
      )),
      cExpr(cCall(cV("f"), [Argument(None(), cLit(25))]))
    ]

    with on[RuntimeError].panic
    with mockGetPos 
    with mockInspector[Unit, Address]
    val result = evalProgram(prog)

    assertTrue(result.equal(VInt(175)))
  }

  test("variable shadowing in local function scope") {
    val prog = [
      cVal("x", None(), cLit(10)),
      cVal("f", None(), cFun(
        [Parameter("y", None(), None())],
        None(),
        Block([
          cVar("x", None(), cLit(20)),
          cAssign("x", cAdd(cV("x"), cLit(5)))
        ], Some(cAdd(cV("x"), cV("y"))))
      )),
      cExpr(cCall(cV("f"), [Argument(None(), cLit(15))]))
    ]

    with on[RuntimeError].panic
    with mockGetPos 
    with mockInspector[Unit, Address]
    val result = evalProgram(prog)

    assertTrue(result.equal(VInt(40)))
  }

  // test("function with complex nested scoping") {
  //   val prog = [
  //     cVal("a", None(), cLit(1)),
  //     cVal("f", None(), cFun(
  //       [Parameter("a", None(), None())],
  //       None(),
  //       Block([
  //         cVal("b", None(), cLit(2)),
  //         cVal("g", None(), cFun(
  //           [Parameter("a", None(), None())],
  //           None(),
  //           Block([
  //             cVal("c", None(), cLit(3))
  //           ], Some(cAdd(cAdd(cV("a"), cV("b")), cV("c"))))
  //         ))
  //       ], Some(cCall(cV("g"), [Argument(None(), cLit(10))])))
  //     )),
  //     cExpr(cCall(cV("f"), [Argument(None(), cLit(100))]))
  //   ]

  //   with on[RuntimeError].panic
  //   with mockGetPos 
  //   with mockInspector[Unit, Address]
  //   val result = evalProgram(prog)

  //   assertTrue(result.equal(VInt(15)))
  // }

  test("function with default parameter value") {
    val prog = [
      cVal("greet", None(), cFun(
        [Parameter("x", None(), Some(cLit(42)))],
        None(),
        Block(Nil(), Some(cV("x")))
      )),
      cExpr(cCall(cV("greet"), Nil()))
    ]

    with on[RuntimeError].panic
    with mockGetPos 
    with mockInspector[Unit, Address]
    val result = evalProgram(prog)

    assertTrue(result.equal(VInt(42)))
  }

  test("function with multiple default parameters") {
    val prog = [
      cVal("defaults", None(), cFun(
        [Parameter("x", None(), Some(cLit(10))), Parameter("y", None(), Some(cLit(20)))],
        None(),
        Block(Nil(), Some(cAdd(cV("x"), cV("y"))))
      )),
      cExpr(cCall(cV("defaults"), Nil()))
    ]

    with on[RuntimeError].panic
    with mockGetPos 
    with mockInspector[Unit, Address]
    val result = evalProgram(prog)

    assertTrue(result.equal(VInt(30)))
  }

  test("function with mixed default and required parameters") {
    val prog = [
      cVal("mixed", None(), cFun(
        [Parameter("x", None(), None()), Parameter("y", None(), Some(cLit(5)))],
        None(),
        Block(Nil(), Some(cAdd(cV("x"), cV("y"))))
      )),
      cExpr(cCall(cV("mixed"), [Argument(None(), cLit(10))]))
    ]

    with on[RuntimeError].panic
    with mockGetPos 
    with mockInspector[Unit, Address]
    val result = evalProgram(prog)

    assertTrue(result.equal(VInt(15)))
  }

  test("function with three nested levels") {
    val prog = [
      cVal("f1", None(), cFun(
        [Parameter("a", None(), None())],
        None(),
        Block([], Some(cFun(
          [Parameter("b", None(), None())],
          None(),
          Block([], Some(cFun(
            [Parameter("c", None(), None())],
            None(),
            Block([], Some(cAdd(cAdd(cV("a"), cV("b")), cV("c"))))
          )))
        )))
      )),
      cVal("f2", None(), cCall(cV("f1"), [Argument(None(), cLit(1))])),
      cVal("f3", None(), cCall(cV("f2"), [Argument(None(), cLit(2))])),
      cExpr(cCall(cV("f3"), [Argument(None(), cLit(3))]))
    ]

    with on[RuntimeError].panic
    with mockGetPos 
    with mockInspector[Unit, Address]
    val result = evalProgram(prog)

    assertTrue(result.equal(VInt(6)))
  }

  test("function call with too few arguments throws error") {
    val prog = [
      cVal("require_two", None(), cFun(
        [Parameter("x", None(), None()), Parameter("y", None(), None())],
        None(),
        Block(Nil(), Some(cAdd(cV("x"), cV("y"))))
      )),
      cExpr(cCall(cV("require_two"), [Argument(None(), cLit(10))]))
    ]

    with mockGetPos 
    with mockInspector[Unit, Address]
    with assertThrows[RuntimeError]
    evalProgram(prog)
    ()
  }

  test("function call with too many arguments throws error") {
    val prog = [
      cVal("one_arg", None(), cFun(
        [Parameter("x", None(), None())],
        None(),
        Block(Nil(), Some(cV("x")))
      )),
      cExpr(cCall(cV("one_arg"), [Argument(None(), cLit(10)), Argument(None(), cLit(20))]))
    ]

    with mockGetPos 
    with mockInspector[Unit, Address]
    with assertThrows[RuntimeError]
    evalProgram(prog)
    ()
  }

  test("calling non-function value throws error") {
    val prog = [
      cVal("x", None(), cLit(42)),
      cExpr(cCall(cV("x"), [Argument(None(), cLit(10))]))
    ]

    with mockGetPos 
    with mockInspector[Unit, Address]
    with assertThrows[RuntimeError]
    evalProgram(prog)
    ()
  }

  test("function with named argument for undefined parameter throws error") {
    val prog = [
      cVal("f", None(), cFun(
        [Parameter("x", None(), None())],
        None(),
        Block(Nil(), Some(cV("x")))
      )),
      cExpr(cCall(cV("f"), [Argument(Some("undefined"), cLit(10))]))
    ]

    with mockGetPos 
    with mockInspector[Unit, Address]
    with assertThrows[RuntimeError]
    evalProgram(prog)
    ()
  }

  test("function parameter modification doesn't affect outer scope") {
    val prog = [
      cVal("x", None(), cLit(100)),
      cVal("f", None(), cFun(
        [Parameter("x", None(), None())],
        None(),
        Block([
          cVar("temp", None(), cV("x")),
          cAssign("temp", cLit(999))
        ], Some(cV("temp")))
      )),
      cExpr(cCall(cV("f"), [Argument(None(), cLit(50))])),
      cExpr(cV("x"))
    ]

    with on[RuntimeError].panic
    with mockGetPos 
    with mockInspector[Unit, Address]
    val result = evalProgram(prog)

    assertTrue(result.equal(VInt(100)))
  }

  test("function modifying outer scope variable") {
    val prog = [
      cVar("counter", None(), cLit(0)),
      cVal("increment", None(), cFun(
        [Parameter("n", None(), None())],
        None(),
        Block([], Some(cV("n")))
      )),
      cVal("result", None(), cCall(cV("increment"), [Argument(None(), cAdd(cV("counter"), cLit(1)))])),
      cExpr(cV("result"))
    ]

    with on[RuntimeError].panic
    with mockGetPos 
    with mockInspector[Unit, Address]
    val result = evalProgram(prog)

    assertTrue(result.equal(VInt(1)))
  }

  test("multiple function definitions with same parameter names") {
    val prog = [
      cVal("f1", None(), cFun(
        [Parameter("x", None(), None())],
        None(),
        Block(Nil(), Some(cMult(cV("x"), cLit(2))))
      )),
      cVal("f2", None(), cFun(
        [Parameter("x", None(), None())],
        None(),
        Block(Nil(), Some(cAdd(cV("x"), cLit(10))))
      )),
      cVal("r1", None(), cCall(cV("f1"), [Argument(None(), cLit(5))])),
      cVal("r2", None(), cCall(cV("f2"), [Argument(None(), cLit(5))])),
      cExpr(cAdd(cV("r1"), cV("r2")))
    ]

    with on[RuntimeError].panic
    with mockGetPos 
    with mockInspector[Unit, Address]
    val result = evalProgram(prog)

    assertTrue(result.equal(VInt(25)))
  }

  test("function inside if expression") {
    val prog = [
      cVal("f", None(), cFun(
        [Parameter("x", None(), None())],
        None(),
        Block(Nil(), Some(cMult(cV("x"), cLit(3))))
      )),
      cExpr(cIf(
        cLit(true),
        cCall(cV("f"), [Argument(None(), cLit(10))]),
        cLit(0)
      ))
    ]

    with on[RuntimeError].panic
    with mockGetPos 
    with mockInspector[Unit, Address]
    val result = evalProgram(prog)

    assertTrue(result.equal(VInt(30)))
  }

  test("function in while loop") {
    val prog = [
      cVal("f", None(), cFun(
        [Parameter("x", None(), None())],
        None(),
        Block(Nil(), Some(cAdd(cV("x"), cLit(1))))
      )),
      cVar("counter", None(), cLit(0)),
      cWhile(
        cLt(cV("counter"), cLit(3)),
        Block([
          cAssign("counter", cCall(cV("f"), [Argument(None(), cV("counter"))]))
        ], None())
      ),
      cExpr(cV("counter"))
    ]

    with on[RuntimeError].panic
    with mockGetPos 
    with mockInspector[Unit, Address]
    val result = evalProgram(prog)

    assertTrue(result.equal(VInt(3)))
  }

  test("shadowing parameter in inner block") {
    val prog = [
      cVal("f", None(), cFun(
        [Parameter("x", None(), None())],
        None(),
        Block([
          cVar("x", None(), cLit(999))
        ], Some(cAdd(cV("x"), cLit(1))))
      )),
      cExpr(cCall(cV("f"), [Argument(None(), cLit(10))]))
    ]

    with on[RuntimeError].panic
    with mockGetPos 
    with mockInspector[Unit, Address]
    val result = evalProgram(prog)

    assertTrue(result.equal(VInt(1000)))
  }

  test("parameter shadowing with same type") {
    val prog = [
      cVal("f", None(), cFun(
        [Parameter("val", None(), None())],
        None(),
        Block([
          cVar("val", None(), cLit(50))
        ], Some(cV("val")))
      )),
      cExpr(cCall(cV("f"), [Argument(None(), cLit(30))]))
    ]

    with on[RuntimeError].panic
    with mockGetPos 
    with mockInspector[Unit, Address]
    val result = evalProgram(prog)

    assertTrue(result.equal(VInt(50)))
  }

  test("complex shadowing with multiple scopes") {
    val prog = [
      cVal("x", None(), cLit(1)),
      cVal("y", None(), cLit(2)),
      cVal("f", None(), cFun(
        [Parameter("x", None(), None())],
        None(),
        Block([
          cVal("y", None(), cLit(200))
        ], Some(cAdd(cV("x"), cV("y"))))
      )),
      cExpr(cCall(cV("f"), [Argument(None(), cLit(100))]))
    ]

    with on[RuntimeError].panic
    with mockGetPos 
    with mockInspector[Unit, Address]
    val result = evalProgram(prog)

    assertTrue(result.equal(VInt(300)))
  }

  test("named arguments in correct order") {
    val prog = [
      cVal("sub", None(), cFun(
        [Parameter("a", None(), None()), Parameter("b", None(), None())],
        None(),
        Block(Nil(), Some(cSub(cV("a"), cV("b"))))
      )),
      cExpr(cCall(cV("sub"), [Argument(Some("a"), cLit(50)), Argument(Some("b"), cLit(20))]))
    ]

    with on[RuntimeError].panic
    with mockGetPos 
    with mockInspector[Unit, Address]
    val result = evalProgram(prog)

    assertTrue(result.equal(VInt(30)))
  }

  test("named arguments in reverse order") {
    val prog = [
      cVal("sub", None(), cFun(
        [Parameter("a", None(), None()), Parameter("b", None(), None())],
        None(),
        Block(Nil(), Some(cSub(cV("a"), cV("b"))))
      )),
      cExpr(cCall(cV("sub"), [Argument(Some("b"), cLit(20)), Argument(Some("a"), cLit(50))]))
    ]

    with on[RuntimeError].panic
    with mockGetPos 
    with mockInspector[Unit, Address]
    val result = evalProgram(prog)

    assertTrue(result.equal(VInt(30)))
  }

  test("partial default parameters with named arguments") {
    val prog = [
      cVal("fn", None(), cFun(
        [Parameter("x", None(), None()), Parameter("y", None(), Some(cLit(100))), Parameter("z", None(), Some(cLit(10)))],
        None(),
        Block(Nil(), Some(cAdd(cAdd(cV("x"), cV("y")), cV("z"))))
      )),
      cExpr(cCall(cV("fn"), [Argument(Some("z"), cLit(20)), Argument(None(), cLit(5))]))
    ]

    with on[RuntimeError].panic
    with mockGetPos 
    with mockInspector[Unit, Address]
    val result = evalProgram(prog)

    assertTrue(result.equal(VInt(125)))
  }

  test("eval string literal") {
    val prog = [cExpr(cLit("hello"))]

    with on[RuntimeError].panic
    with mockGetPos
    with mockInspector[Unit, Address]
    val result = evalProgram(prog)

    assertTrue(result.equal(VString("hello")))
  }

  test("eval string concatenation") {
    val prog = [cExpr(cAdd(cLit("hello"), cLit("world")))]

    with on[RuntimeError].panic
    with mockGetPos
    with mockInspector[Unit, Address]
    val result = evalProgram(prog)

    assertTrue(result.equal(VString("helloworld")))
  }

  test("eval string equality") {
    val prog = [cExpr(cEq(cLit("echo"), cLit("echo")))]

    with on[RuntimeError].panic
    with mockGetPos
    with mockInspector[Unit, Address]
    val result = evalProgram(prog)

    assertTrue(result.equal(VBool(true)))
  }

  test("eval double literal") {
    val prog = [cExpr(cLit(3.14))]

    with on[RuntimeError].panic
    with mockGetPos
    with mockInspector[Unit, Address]
    val result = evalProgram(prog)

    assertTrue(result.equal(VDouble(3.14)))
  }

  test("eval double arithmetic") {
    val progs = [
      [cExpr(cAdd(cLit(1.5), cLit(2.5)))],
      [cExpr(cSub(cLit(5.0), cLit(3.0)))],
      [cExpr(cMult(cLit(2.0), cLit(4.0)))],
      [cExpr(cDiv(cLit(9.0), cLit(3.0)))]
    ]

    val expected = [
      VDouble(4.0),
      VDouble(2.0),
      VDouble(8.0),
      VDouble(3.0)
    ]

    var iter = 0
    while(iter < progs.size) {
      with on[RuntimeError].panic
      with on[OutOfBounds].panic
      with mockGetPos
      with mockInspector[Unit, Address]

      val result = evalProgram(progs.get(iter))
      assertTrue(result.equal(expected.get(iter)))
      iter = iter + 1
    }
  }

  test("eval truthy value in if expression") {
    val prog = [cExpr(cIf(cLit(5), cLit(10), cLit(20)))]

    with on[RuntimeError].panic
    with mockGetPos
    with mockInspector[Unit, Address]
    val result = evalProgram(prog)

    assertTrue(result.equal(VInt(10)))
  }

  test("eval falsy value in if expression") {
    val prog = [cExpr(cIf(cLit(0), cLit(10), cLit(20)))]

    with on[RuntimeError].panic
    with mockGetPos
    with mockInspector[Unit, Address]
    val result = evalProgram(prog)

    assertTrue(result.equal(VInt(20)))
  }

  test("eval truthy value in while loop") {
    val prog = [
      cVar("counter", None(), cLit(3)),
      cVar("sum", None(), cLit(0)),
      cWhile(cV("counter"), 
        Block([cAssign("counter", cSub(cV("counter"), cLit(1))),
        cAssign("sum", cAdd(cV("sum"), cV("counter")))], None())
        ),
      cExpr(cV("sum"))
    ]

    with on[RuntimeError].panic
    with mockGetPos
    with mockInspector[Unit, Address]
    val result = evalProgram(prog)

    assertTrue(result.equal(VInt(3)))
  }

  test("eval truthy in 'and' (Int)") {
    val prog = [cExpr(cAnd(cLit(5), cLit(10)))]
    
    with on[RuntimeError].panic
    with mockGetPos
    with mockInspector[Unit, Address]
    val result = evalProgram(prog)

    assertTrue(result.equal(VBool(true)))
  }

  test("eval truthy in `or` (Int)") {
    val prog = [cExpr(cOr(cLit(0), cLit(10)))]
    
    with on[RuntimeError].panic
    with mockGetPos
    with mockInspector[Unit, Address]
    val result = evalProgram(prog)

    assertTrue(result.equal(VBool(true)))
  }

  test("eval falsy in `and` (Int)") {
    val prog = [cExpr(cAnd(cLit(0), cLit(10)))]
    
    with on[RuntimeError].panic
    with mockGetPos
    with mockInspector[Unit, Address]
    val result = evalProgram(prog)

    assertTrue(result.equal(VBool(false)))
  }

  test("eval falsy in `or` (Int)") {
    val prog = [cExpr(cOr(cLit(0), cLit(5)))]
    
    with on[RuntimeError].panic
    with mockGetPos
    with mockInspector[Unit, Address]
    val result = evalProgram(prog)

    assertTrue(result.equal(VBool(true)))
  }

  test("eval truthy in 'and' (Double)") {
    val prog = [cExpr(cAnd(cLit(5.0), cLit(10.0)))]
    
    with on[RuntimeError].panic
    with mockGetPos
    with mockInspector[Unit, Address]
    val result = evalProgram(prog)

    assertTrue(result.equal(VBool(true)))
  }

  test("eval truthy in `or` (Double)") {
    val prog = [cExpr(cOr(cLit(0.0), cLit(10.0)))]

    with on[RuntimeError].panic
    with mockGetPos
    with mockInspector[Unit, Address]
    val result = evalProgram(prog)

    assertTrue(result.equal(VBool(true)))
  }

  test("eval falsy in 'and' (Double)") {
    val prog = [cExpr(cAnd(cLit(0.0), cLit(10.0)))]

    with on[RuntimeError].panic
    with mockGetPos
    with mockInspector[Unit, Address]
    val result = evalProgram(prog)

    assertTrue(result.equal(VBool(false)))
  }

  test("eval falsy in `or` (Double)") {
    val prog = [cExpr(cOr(cLit(0.0), cLit(5.0)))]

    with on[RuntimeError].panic
    with mockGetPos
    with mockInspector[Unit, Address]
    val result = evalProgram(prog)

    assertTrue(result.equal(VBool(true)))
  }

  test("eval truthy in 'and' (String)") {
    val prog = [cExpr(cAnd(cLit("hello"), cLit("world")))]
    
    with on[RuntimeError].panic
    with mockGetPos
    with mockInspector[Unit, Address]
    val result = evalProgram(prog)
  
    assertTrue(result.equal(VBool(true)))
  }

  test("eval truthy in `or` (String)") {
    val prog = [cExpr(cOr(cLit(""), cLit("world")))]
    
    with on[RuntimeError].panic
    with mockGetPos
    with mockInspector[Unit, Address]
    val result = evalProgram(prog)

    assertTrue(result.equal(VBool(true)))
  }

  test("eval falsy in 'and' (String)") {
    val prog = [cExpr(cAnd(cLit(""), cLit("world")))]
    
    with on[RuntimeError].panic
    with mockGetPos
    with mockInspector[Unit, Address]
    val result = evalProgram(prog)

    assertTrue(result.equal(VBool(false)))
  }

  test("eval falsy in `or` (String)") {
    val prog = [cExpr(cOr(cLit(""), cLit("world")))]
    
    with on[RuntimeError].panic
    with mockGetPos
    with mockInspector[Unit, Address]
    val result = evalProgram(prog)

    assertTrue(result.equal(VBool(true)))
  }
}