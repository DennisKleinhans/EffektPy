module src/tests/testPipeline

import test
import src/lib/shared/helpers
import src/lib/runner/runPipeline
import src/lib/interpreter/values
import src/tests/helpers/testUtils


def main() = mainSuite("pipeline") {

  test("simple arithmetic") {
    val result = runPipeline("val x = 10 + 20 * 3\nx")
    assertTrue(result.equal(VInt(70)))
  }

  test("compare expressions") {
    val result = runPipeline("val x = 10 < 20\nx")
    assertTrue(result.equal(VBool(true)))
  }

  test("compare chain expressions") {
    val result = runPipeline("val x = 10 < 20 < 30\nx")
    assertTrue(result.equal(VBool(true)))
  }

  test("if expression"){
    val result = runPipeline("val x = if 10 < 20 then 1 else 2\nx")
    assertTrue(result.equal(VInt(1)))
  }

  test("if expression without assignment") {
    val result = runPipeline("if 10 < 20 then 1 else 2")
    assertTrue(result.equal(VInt(1)))
  }

  test("nested if expression"){
    val result = runPipeline(
      """val x = if 10 < 20 then (if 5 > 3 then 2 else 3) else 4
      x
      """)
    assertTrue(result.equal(VInt(2)))
  }

  test("if statement without else") {
    val result = runPipeline("""
      if (10 < 5) {
        val x = 2
      }
    """)
    assertTrue(result.equal(VUnit()))
  }

  test("if statement with else") {
    val result = runPipeline("""
      if (10 < 5) {
        val x = 2
        x
      } else {
        val x = 5
        x
      }
    """)
    assertTrue(result.equal(VInt(5)))
  }

  test("nested if statements") {
    val result = runPipeline("""
      var x = 0
      if (10 < 20) {
        if (true) {
          x = 2
        }
      } else {
        x = 5
      }
      x
    """)
    assertTrue(result.equal(VInt(2)))
  }

  test("variable assignment and update") {
    val result = runPipeline("""
      var x = 10
      x = x + 5
      x
    """)
    assertTrue(result.equal(VInt(15)))
  }

  test("compund assignment plus") {
    val result = runPipeline("""
      var x = 10
      x += 1
      x
    """)
    assertTrue(result.equal(VInt(11)))
  }

  test("compound assignment minus") {
    val result = runPipeline("""
      var x = 10
      x -= 2
      x
    """)
    assertTrue(result.equal(VInt(8)))
  }

  test("shadowing in if blocks") {
    val result = runPipeline("""
      var x = 10
      if (true) {
        val x = 20
        x
      } else {
        val x = 30
        x
      }
    """)
    assertTrue(result.equal(VInt(20)))
  }

  test("shadowing in nested if blocks") {
    val result = runPipeline("""
      var x = 10
      if (true) {
        val x = 20
        if (false) {
          val x = 40
          x
        } else {
          val x = 30
          x
        }
      } else {
        val x = 50
        x
      }
    """)
    assertTrue(result.equal(VInt(30)))
  }

  test("complex program: nested ifs and assignments") {
    val result = runPipeline("""
      var x = 5
      var y = 10
      if (x < y) {
        x = x + 15
        if (y > 5) {
          y += 20
        } else {
          y += 30
        }
      } else {
        x += 25
      }
      x + y
    """)
    assertTrue(result.equal(VInt(50)))
  }

  test("while loop") {
    val result = runPipeline("""
      var x = 0
      while (x < 5) {
        x += 1
      }
      x
    """)
    assertTrue(result.equal(VInt(5)))
  }

  test("while loop with if statement inside") {
    val result = runPipeline("""
      var x = 0
      var y = 0
      while (x < 5) {
        if (x == 2) {
          y += 3
        }
        x += 1
      }
      y + x
    """)
    assertTrue(result.equal(VInt(8)))
  }

  test("while loop with nested if statements") {
    val result = runPipeline("""
      var x = 0
      var y = 0
      while (x < 5) {
        if (x < 3) {
          if (x == 1) {
            y += 10
          } else {
            y += 1
          }
        }
        x += 1
      }
      y + x
    """)
    assertTrue(result.equal(VInt(17)))
  }

  test("full feature program: annotations, chains, shadowing, loops") {
    val result = runPipeline("""
      val base: Int = 3 * 2 + 1 
      var acc: Int = base 
      var counter = 0
      var guard: Bool = true
      val chainOk: Bool = 0 < base < 10

      while (counter < 5) {
        if (counter == 2 or not chainOk) {
          val shadow = acc
          acc = shadow + counter
        } else {
          var bump = counter * 2
          acc = acc + bump
        }
        counter += 1
      }

      while (guard and (counter >= 5)) {
        if (0 < acc < 100) {
          acc -= 3
          guard = false
        } else {
          acc += 1
        }
      }

      val finalVal = if guard then -acc else acc / 2
      finalVal + acc
    """)
    assertTrue(result.equal(VInt(33)))
  }

  test("full feature program: break and continue in loops") {
    val result = runPipeline("""
      var x: Int = 0
      var sum: Int = 0
      var multiplier: Int = 1
      val limit: Bool = 10 < 20

      while (x < 10) {
        if (x == 3) {
          x += 1
          continue
        }

        if (x == 7 and limit) {
          break
        }

        if (x > 0 and x < 6) {
          sum = sum + x
          multiplier = multiplier * 2
        }

        x += 1
      }

      var result: Int = 0
      var iter: Int = 0
      while (iter < 3) {
        if (iter == 1) {
          val skipped = 100
          iter += 1
          continue
        }

        if (iter == 2) {
          result = result + 50
          break
        }

        result = result + 10
        iter += 1
      }

      sum + result + multiplier
    """)
    assertTrue(result.equal(VInt(88)))
  }

  test("simple function definition and call") {
    val result = runPipeline("""
      def add(a: Int, b: Int): Int { a + b }
      add(5, 3)
    """)
    assertTrue(result.equal(VInt(8)))
  }

  test("function with multiple parameters") {
    val result = runPipeline("""
      def multiply(x: Int, y: Int, z: Int): Int { x * y * z }
      multiply(2, 3, 4)
    """)
    assertTrue(result.equal(VInt(24)))
  }

  test("nested function calls") {
    val result = runPipeline("""
      def add(a: Int, b: Int): Int { a + b }
      def multiply(x: Int, y: Int): Int { x * y }
      multiply(add(2, 3), 4)
    """)
    assertTrue(result.equal(VInt(20)))
  }

  test("function with variable assignment") {
    val result = runPipeline("""
      def compute(x: Int): Int { 
        var result = x * 2
        result += 5
        result
      }
      compute(10)
    """)
    assertTrue(result.equal(VInt(25)))
  }

  test("function with if statement") {
    val result = runPipeline("""
      def absolute(x: Int): Int { if x < 0 then -x else x }
      absolute(-15)
    """)
    assertTrue(result.equal(VInt(15)))
  }

  test("simple lambda") {
    val result = runPipeline("""
      val add = lambda(x: Int) { x + 10 }
      add(5)
    """)
    assertTrue(result.equal(VInt(15)))
  }

  test("lambda with multiple parameters") {
    val result = runPipeline("""
      val multiply = lambda(x: Int) { lambda(y: Int) { x * y } }
      multiply(3)(4)
    """)
    assertTrue(result.equal(VInt(12)))
  }

  test("function returning lambda") {
    val result = runPipeline("""
      def makeAdder(n: Int): Int -> Int { lambda (x: Int) { x + n } }
      val addFive = makeAdder(5)
      addFive(10)
    """)
    assertTrue(result.equal(VInt(15)))
  }

  test("function returning lambda with multiple parameters") {
    val result = runPipeline("""
      def makeMultiplier(factor: Int): (Int, Int) -> Int { 
        lambda (x: Int, y: Int) { x * y * factor } 
      }
      val doubleMultiplier = makeMultiplier(2)
      doubleMultiplier(3, 4)
    """)
    assertTrue(result.equal(VInt(24)))
  }

  test("lambda in loop") {
    val result = runPipeline("""
      var result = 0
      val addTo = lambda(x: Int) { lambda(y: Int) { x + y } }
      var i = 0
      while (i < 5) {
        result = addTo(result)(i)
        i += 1
      }
      result
    """)
    assertTrue(result.equal(VInt(10)))
  }

  test("function with lambda parameter") {
    val result = runPipeline("""
      def apply(f: Int -> Int, x: Int): Int { f(x) }
      val double = lambda(x: Int) { x * 2 }
      apply(double, 7)
    """)
    assertTrue(result.equal(VInt(14)))
  }

  test("function with multi-parameter lambda") {
    val result = runPipeline("""
      def applyBinary(f: (Int, Int) -> Int, x: Int, y: Int): Int { f(x, y) }
      val add = lambda(a: Int, b: Int) { a + b }
      applyBinary(add, 5, 8)
    """)
    assertTrue(result.equal(VInt(13)))
  }

  test("chained lambda calls") {
    val result = runPipeline("""
      val add = lambda (x: Int) { lambda (y: Int) { x + y } }
      val mul = lambda (x: Int) { lambda (y: Int) { x * y } }
      add(mul(3)(4))(5)
    """)
    assertTrue(result.equal(VInt(17)))
  }

  test("function using shadowing in loops") {
    val result = runPipeline("""
      def accumulate(limit: Int): Int {
        var acc = 0
        var i = 0
        while (i < limit) {
          val x = i * 2
          acc += x
          i += 1
        }
        acc
      }
      accumulate(5)
    """)
    assertTrue(result.equal(VInt(20)))
  }

  test("lambda with if expression") {
    val result = runPipeline("""
      val maxNum = lambda (x: Int) { lambda (y: Int) { if x > y then x else y } }
      maxNum(15)(8)
    """)
    assertTrue(result.equal(VInt(15)))
  }

   test("function with default parameters") {
    val result = runPipeline("""
      def add(a: Int, b: Int = 10): Int {
        a + b
      }
      add(5)
    """)
    assertTrue(result.equal(VInt(15)))
  }

  test("function with default parameters overridden") {
    val result = runPipeline("""
      def add(a: Int, b: Int = 10): Int {
        a + b
      }
      add(5, 20)
    """)
    assertTrue(result.equal(VInt(25)))
  }

  test("function without type annotations") {
    val result = runPipeline("""
      def multiply(x, y) {
        x * y
      }
      multiply(4, 5)
    """)
    assertTrue(result.equal(VInt(20)))
  }

  test("function with mixed type annoations and default paramters") {
    val result = runPipeline("""
      def compute(x: Int, y = 5, z: Int = 10) {
        x + y + z
      }
      compute(15)
    """)
    assertTrue(result.equal(VInt(30)))
  }

  test("higher-order function") {
    val result = runPipeline("""
      def applyFunction(f: Int -> Int, value: Int): Int {
        f(value)
      }
      def square(x: Int) { x * x }
      applyFunction(square, 6)
    """)
    assertTrue(result.equal(VInt(36)))
  }

    test("higher-order function without type annotations") {
    val result = runPipeline("""
      def applyFunction(f, value) {
        f(value)
      }
      def square(x) { x * x }
      applyFunction(square, 6)
    """)
    assertTrue(result.equal(VInt(36)))
  }

  test("function with Unit type annotation") {
    val result = runPipeline("""
      def printValue(x: Int): Unit {
        val y = x + 10
      }
      printValue(5)
    """)
    assertTrue(result.equal(VUnit()))
  }
  
  test("complex program combining all features") {
    val result = runPipeline("""
      def complexFunction(a: Int, b: Int): Int {
        var result = 0
        val compute = lambda (x: Int) {
          if x < 0 then -x else x
        }
        
        var i = a
        while (i < b) {
          val valToAdd = compute(i)
          result += valToAdd
          i += 1
        }
        
        result
      }
      
      complexFunction(-3, 4)
    """)
    assertTrue(result.equal(VInt(12)))
  } 

  test("string literals and concatenation with annotation") {
    val result = runPipeline("""
      val greeting: String = "hello"
      val target: String = "world"
      val message: String = greeting + " " + target
      message
    """)
    assertTrue(result.equal(VString("hello world")))
  }

  test("double arithmetic with annotation") {
    val result = runPipeline("""
      val base: Double = 2.5 * 4.0
      val half: Double = base / 2.0
      half
    """)
    assertTrue(result.equal(VDouble(5.0)))
  }

  test("functions operating on doubles") {
    val result = runPipeline("""
      def scale(x: Double, factor: Double): Double { x * factor }
      scale(2.0, 3.0)
    """)
    assertTrue(result.equal(VDouble(6.0)))
  }

  test("functions operating on strings") {
    val result = runPipeline("""
      def greet(name: String): String { name + "!" }
      greet("Ada")
    """)
    assertTrue(result.equal(VString("Ada!")))
  }

  test("string escape sequences") {
    val result = runPipeline("""
      val text: String = "Line1\nLine2\tTabbed"
      text
    """)
    assertTrue(result.equal(VString("Line1\nLine2\tTabbed")))
  }

  test("truthy Int value in 'not'") {
    val result = runPipeline("""
      val x = not 5
      x
    """)
    assertTrue(result.equal(VBool(false)))
  }

  test("falsy Int value in 'not'") {
    val result = runPipeline("""
      val x = not 0
      x
    """)
    assertTrue(result.equal(VBool(true)))
  }

  test("truthy Double value in 'not'") {
    val result = runPipeline("""
      val x = not 3.14
      x
    """)
    assertTrue(result.equal(VBool(false)))
  }

  test("falsy Double value in 'not'") {
    val result = runPipeline("""
      val x = not 0.0
      x
    """)
    assertTrue(result.equal(VBool(true)))
  }

  test("truthy String value in 'not'") {
    val result = runPipeline("""
      val x = not "hello"
      x
    """)
    assertTrue(result.equal(VBool(false)))
  }

  test("falsy String value in 'not'") {
    val result = runPipeline("""
      val x = not ""
      x
    """)
    assertTrue(result.equal(VBool(true)))
  }

  test("truthy values in if condition") {
    val result = runPipeline("""
      def add(a, b): Int {
        a + b
      }

      if (add(2, 3)) {
        10
      } else {
        20
      }
    """)
    assertTrue(result.equal(VInt(10)))
  }

  test("truthy values in while condition") {
    val result = runPipeline("""
      var count = 3
      var sum = 0

      while (count) {
        sum += count
        count -= 1
      }

      sum
    """)
    assertTrue(result.equal(VInt(6)))
  }

  test("mutal recursion") {
    val result = runPipeline("""
      def isEven(n) {
        if n == 0 then true else isOdd(n - 1)
      }

      def isOdd(n) {
        if n == 0 then false else isEven(n - 1)
      }

      isEven(10)
    """)
    assertTrue(result.equal(VBool(true)))
  }

  test("nested mutal recursion") {
    val result = runPipeline("""
      def outer(n) {
        def isEven(n) {
          if n == 0 then true else isOdd(n - 1)
        }

        def isOdd(n) {
          if n == 0 then false else isEven(n - 1)
        }

        isOdd(n)
      }

      outer(7)
    """)
    assertTrue(result.equal(VBool(true)))
  }

  test("simple recursive factorial") {
    val result = runPipeline("""
      def factorial(n) {
        if n <= 1 then 1 else n * factorial(n - 1)
      }
      factorial(5)
    """)
    assertTrue(result.equal(VInt(120)))
  }

  test("recursive fibonacci") {
    val result = runPipeline("""
      def fib(n) {
        if n <= 1 then n else fib(n - 1) + fib(n - 2)
      }
      fib(8)
    """)
    assertTrue(result.equal(VInt(21)))
  }

  test("tail-recursive sum with accumulator") {
    val result = runPipeline("""
      def sumTo(n, acc = 0) {
        if n <= 0 then acc else sumTo(n - 1, acc + n)
      }
      sumTo(10)
    """)
    assertTrue(result.equal(VInt(55)))
  }

  test("recursive power function") {
    val result = runPipeline("""
      def power(base, exp) {
        if exp == 0 then 1 else base * power(base, exp - 1)
      }
      power(2, 10)
    """)
    assertTrue(result.equal(VInt(1024)))
  }

  test("recursive GCD (greatest common divisor)") {
    val result = runPipeline("""
      def gcd(a, b) {
        if b == 0 then a else gcd(b, a - (a / b) * b)
      }
      gcd(48, 18)
    """)
    assertTrue(result.equal(VInt(6)))
  }

  test("recursive list sum simulation with counter") {
    val result = runPipeline("""
      def sumRange(start, end) {
        if start > end then 0 else start + sumRange(start + 1, end)
      }
      sumRange(1, 100)
    """)
    assertTrue(result.equal(VInt(5050)))
  }

  test("recursion with lambda") {
    val result = runPipeline("""
      def applyN(f, n, x) {
        if n <= 0 then x else applyN(f, n - 1, f(x))
      }
      val double = lambda(x) { x * 2 }
      applyN(double, 4, 3)
    """)
    assertTrue(result.equal(VInt(48)))
  }

  test("recursion with mutable state") {
    val result = runPipeline("""
      var globalSum = 0
      
      def addToGlobal(n) {
        if (n > 0) {
          globalSum = globalSum + n
          addToGlobal(n - 1)
        }
      }
      
      addToGlobal(10)
      globalSum
    """)
    assertTrue(result.equal(VInt(55)))
  }

  test("nested recursion with different functions") {
    val result = runPipeline("""
      def outer(n) {
        def inner(m) {
          if m <= 0 then 1 else m * inner(m - 1)
        }
        if n <= 0 then 0 else inner(n) + outer(n - 1)
      }
      outer(4)
    """)
    assertTrue(result.equal(VInt(33)))
  }

  test("recursion with complex conditionals and loops") {
    val result = runPipeline("""
      def compute(n) {
        if (n <= 1) {
          n
        } else {
          var sum = 0
          var i = 0
          while (i < 2) {
            sum = sum + compute(n - i - 1)
            i += 1
          }
          sum
        }
      }
      compute(7)
    """)
    assertTrue(result.equal(VInt(13)))
  }

  test("higher-order recursion with function parameter") {
    val result = runPipeline("""
      def repeat(f, n, x) {
        if n <= 0 then x else repeat(f, n - 1, f(x))
      }
      
      def addThree(x) { x + 3 }
      
      repeat(addThree, 5, 10)
    """)
    assertTrue(result.equal(VInt(25)))
  }

  test("recursive function returning lambda") {
    val result = runPipeline("""
      def makeCounter(n) {
        if n <= 0 then
          lambda(x) { x }
        else
          lambda(x) { makeCounter(n - 1)(x + 1) }
      }
      
      makeCounter(5)(0)
    """)
    assertTrue(result.equal(VInt(5)))
  }

  test("recursion with string concatenation") {
    val result = runPipeline("""
      def repeat(str, n) {
        if n <= 0 then "" else str + repeat(str, n - 1)
      }
      repeat("ab", 4)
    """)
    assertTrue(result.equal(VString("abababab")))
  }

  test("complex program with nested recursion and all features") {
    val result = runPipeline("""
      def complexCalc(n) {
        var result = 0
        
        def factorial(x) {
          if x <= 1 then 1 else x * factorial(x - 1)
        }
        
        def sumDigits(num, acc = 0) {
          if num <= 0 then acc else sumDigits(num / 10, acc + (num - (num / 10) * 10))
        }
        
        var i = 1
        while (i <= n) {
          val fact = factorial(i)
          val digitSum = sumDigits(fact)
          
          if (digitSum > 5) {
            result = result + digitSum
          } else {
            result = result + fact
          }
          
          i += 1
        }
        
        result
      }
      
      complexCalc(5)
    """)
    assertTrue(result.equal(VInt(135)))
  }

  test("recursion with break in loop inside recursive function") {
    val result = runPipeline("""
      def process(n) {
        if (n <= 0){
          0
        } else {
          var sum = 0
          var i = 0
          while (i < 10) {
            if (i == n) {
              break
            }
            sum += i
            i += 1
          }
          sum + process(n - 1)
        }
      }
      process(5)
    """)
    assertTrue(result.equal(VInt(20)))
  }

  test("recursion with continue in loop") {
    val result = runPipeline("""
      def sumOddUpTo(n) {
        if (n <= 0) {
          0
        } else {
          var sum = 0
          var i = 0
          while (i <= n) {
            if (i - (i / 2) * 2 == 0) {
              i += 1
              continue
            }
            sum += i
            i += 1
          }
          sum
        }
      }
      sumOddUpTo(10)
    """)
    assertTrue(result.equal(VInt(25)))
  }

}