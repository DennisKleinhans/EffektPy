module src/tests/testPipeline

import test
import src/lib/runner/runPipeline
import src/lib/utils/testUtils
import src/lib/utils/helpers
import src/lib/interpreter/values

def main() = mainSuite("pipeline") {

  test("simple arithmetic") {
    val result = runPipeline("val x = 10 + 20 * 3\nx")
    assertTrue(result.equal(VInt(70)))
  }

  test("compare expressions") {
    val result = runPipeline("val x = 10 < 20\nx")
    assertTrue(result.equal(VBool(true)))
  }

  test("compare chain expressions") {
    val result = runPipeline("val x = 10 < 20 < 30\nx")
    assertTrue(result.equal(VBool(true)))
  }

  test("if expression"){
    val result = runPipeline("val x = if 10 < 20 then 1 else 2\nx")
    assertTrue(result.equal(VInt(1)))
  }

  test("if expression without assignment") {
    val result = runPipeline("if 10 < 20 then 1 else 2")
    assertTrue(result.equal(VInt(1)))
  }

  test("nested if expression"){
    val result = runPipeline("val x = if 10 < 20 then (if 5 > 3 then 2 else 3) else 4\nx")
    assertTrue(result.equal(VInt(2)))
  }

  test("if statement without else") {
    val result = runPipeline("""
      if (10 < 5) {
        val x = 2
        x
      }
    """)
    assertTrue(result.equal(VUnit()))
  }

  test("if statement with else") {
    val result = runPipeline("""
      if (10 < 5) {
        val x = 2
        x
      } else {
        val x = 5
        x
      }
    """)
    assertTrue(result.equal(VInt(5)))
  }

  test("nested if statements") {
    val result = runPipeline("""
      if (10 < 20) {
        if (true) {
          val x = 2
          x
        }
      } else {
        val x = 5
        x
      }
    """)
    assertTrue(result.equal(VInt(2)))
  }

  test("variable assignment and update") {
    val result = runPipeline("""
      var x = 10
      x = x + 5
      x
    """)
    assertTrue(result.equal(VInt(15)))
  }

  test("compund assignment plus") {
    val result = runPipeline("""
      var x = 10
      x += 1
      x
    """)
    assertTrue(result.equal(VInt(11)))
  }

  test("compound assignment minus") {
    val result = runPipeline("""
      var x = 10
      x -= 2
      x
    """)
    assertTrue(result.equal(VInt(8)))
  }

  test("shadowing in if blocks") {
    val result = runPipeline("""
      var x = 10
      if (true) {
        val x = 20
        x
      } else {
        val x = 30
        x
      }
    """)
    assertTrue(result.equal(VInt(20)))
  }

  test("shadowing in nested if blocks") {
    val result = runPipeline("""
      var x = 10
      if (true) {
        val x = 20
        if (false) {
          val x = 40
          x
        } else {
          val x = 30
          x
        }
      } else {
        val x = 50
        x
      }
    """)
    assertTrue(result.equal(VInt(30)))
  }

  test("complex program: nested ifs and assignments") {
    val result = runPipeline("""
      var x = 5
      var y = 10
      if (x < y) {
        x = x + 15
        if (y > 5) {
          y += 20
        } else {
          y += 30
        }
      } else {
        x += 25
      }
      x + y
    """)
    assertTrue(result.equal(VInt(50)))
  }

  test("while loop") {
    val result = runPipeline("""
      var x = 0
      while (x < 5) {
        x += 1
      }
      x
    """)
    assertTrue(result.equal(VInt(5)))
  }

  test("while loop with if statement inside") {
    val result = runPipeline("""
      var x = 0
      var y = 0
      while (x < 5) {
        if (x == 2) {
          y += 3
        }
        x += 1
      }
      y + x
    """)
    assertTrue(result.equal(VInt(8)))
  }

  test("while loop with nested if statements") {
    val result = runPipeline("""
      var x = 0
      var y = 0
      while (x < 5) {
        if (x < 3) {
          if (x == 1) {
            y += 10
          } else {
            y += 1
          }
        }
        x += 1
      }
      y + x
    """)
    assertTrue(result.equal(VInt(17)))
  }

  test("full feature program: annotations, chains, shadowing, loops") {
    val result = runPipeline("""
      val base: Int = 3 * 2 + 1 
      var acc: Int = base 
      var counter = 0
      var guard: Bool = true
      val chainOk: Bool = 0 < base < 10

      while (counter < 5) {
        if (counter == 2 or not chainOk) {
          val shadow = acc
          acc = shadow + counter
        } else {
          var bump = counter * 2
          acc = acc + bump
        }
        counter += 1
      }

      while (guard and (counter >= 5)) {
        if (0 < acc < 100) {
          acc -= 3
          guard = false
        } else {
          acc += 1
        }
      }

      val finalVal = if guard then -acc else acc / 2
      finalVal + acc
    """)
    assertTrue(result.equal(VInt(33)))
  }

  test("full feature program: break and continue in loops") {
    val result = runPipeline("""
      var x: Int = 0
      var sum: Int = 0
      var multiplier: Int = 1
      val limit: Bool = 10 < 20

      while (x < 10) {
        if (x == 3) {
          x += 1
          continue
        }

        if (x == 7 and limit) {
          break
        }

        if (x > 0 and x < 6) {
          sum = sum + x
          multiplier = multiplier * 2
        }

        x += 1
      }

      var result: Int = 0
      var iter: Int = 0
      while (iter < 3) {
        if (iter == 1) {
          val skipped = 100
          iter += 1
          continue
        }

        if (iter == 2) {
          result = result + 50
          break
        }

        result = result + 10
        iter += 1
      }

      sum + result + multiplier
    """)
    assertTrue(result.equal(VInt(88)))
  }

  test("simple function definition and call") {
    val result = runPipeline("""
      def add(a: Int, b: Int): Int { a + b }
      add(5, 3)
    """)
    assertTrue(result.equal(VInt(8)))
  }

  test("function with multiple parameters") {
    val result = runPipeline("""
      def multiply(x: Int, y: Int, z: Int): Int { x * y * z }
      multiply(2, 3, 4)
    """)
    assertTrue(result.equal(VInt(24)))
  }

  test("nested function calls") {
    val result = runPipeline("""
      def add(a: Int, b: Int): Int { a + b }
      def multiply(x: Int, y: Int): Int { x * y }
      multiply(add(2, 3), 4)
    """)
    assertTrue(result.equal(VInt(20)))
  }

  test("function with variable assignment") {
    val result = runPipeline("""
      def compute(x: Int): Int { 
        var result = x * 2
        result += 5
        result
      }
      compute(10)
    """)
    assertTrue(result.equal(VInt(25)))
  }

  test("function with if statement") {
    val result = runPipeline("""
      def absolute(x: Int): Int { if x < 0 then -x else x }
      absolute(-15)
    """)
    assertTrue(result.equal(VInt(15)))
  }

  test("simple lambda") {
    val result = runPipeline("""
      val add = lambda(x: Int) { x + 10 }
      add(5)
    """)
    assertTrue(result.equal(VInt(15)))
  }

  test("lambda with multiple parameters") {
    val result = runPipeline("""
      val multiply = lambda(x: Int) { lambda(y: Int) { x * y } }
      multiply(3)(4)
    """)
    assertTrue(result.equal(VInt(12)))
  }

  test("function returning lambda") {
    val result = runPipeline("""
      def makeAdder(n: Int): Int -> Int { lambda (x: Int) { x + n } }
      val addFive = makeAdder(5)
      addFive(10)
    """)
    assertTrue(result.equal(VInt(15)))
  }

  test("function returning lambda with multiple parameters") {
    val result = runPipeline("""
      def makeMultiplier(factor: Int): (Int, Int) -> Int { 
        lambda (x: Int, y: Int) { x * y * factor } 
      }
      val doubleMultiplier = makeMultiplier(2)
      doubleMultiplier(3, 4)
    """)
    assertTrue(result.equal(VInt(24)))
  }

  test("lambda in loop") {
    val result = runPipeline("""
      var result = 0
      val addTo = lambda(x: Int) { lambda(y: Int) { x + y } }
      var i = 0
      while (i < 5) {
        result = addTo(result)(i)
        i += 1
      }
      result
    """)
    assertTrue(result.equal(VInt(10)))
  }

  test("function with lambda parameter") {
    val result = runPipeline("""
      def apply(f: Int -> Int, x: Int): Int { f(x) }
      val double = lambda(x: Int) { x * 2 }
      apply(double, 7)
    """)
    assertTrue(result.equal(VInt(14)))
  }

  test("function with multi-parameter lambda") {
    val result = runPipeline("""
      def applyBinary(f: (Int, Int) -> Int, x: Int, y: Int): Int { f(x, y) }
      val add = lambda(a: Int, b: Int) { a + b }
      applyBinary(add, 5, 8)
    """)
    assertTrue(result.equal(VInt(13)))
  }

  test("chained lambda calls") {
    val result = runPipeline("""
      val add = lambda (x: Int) { lambda (y: Int) { x + y } }
      val mul = lambda (x: Int) { lambda (y: Int) { x * y } }
      add(mul(3)(4))(5)
    """)
    assertTrue(result.equal(VInt(17)))
  }

  test("function using shadowing in loops") {
    val result = runPipeline("""
      def accumulate(limit: Int): Int {
        var acc = 0
        var i = 0
        while (i < limit) {
          val x = i * 2
          acc += x
          i += 1
        }
        acc
      }
      accumulate(5)
    """)
    assertTrue(result.equal(VInt(20)))
  }

  test("lambda with if expression") {
    val result = runPipeline("""
      val maxNum = lambda (x: Int) { lambda (y: Int) { if x > y then x else y } }
      maxNum(15)(8)
    """)
    assertTrue(result.equal(VInt(15)))
  }

   test("function with default parameters") {
    val result = runPipeline("""
      def add(a: Int, b: Int = 10): Int {
        a + b
      }
      add(5)
    """)
    assertTrue(result.equal(VInt(15)))
  }

  test("function with default parameters overridden") {
    val result = runPipeline("""
      def add(a: Int, b: Int = 10): Int {
        a + b
      }
      add(5, 20)
    """)
    assertTrue(result.equal(VInt(25)))
  }

  test("function without type annotations") {
    val result = runPipeline("""
      def multiply(x, y) {
        x * y
      }
      multiply(4, 5)
    """)
    assertTrue(result.equal(VInt(20)))
  }

  test("function with mixed type annoations and default paramters") {
    val result = runPipeline("""
      def compute(x: Int, y = 5, z: Int = 10) {
        x + y + z
      }
      compute(15)
    """)
    assertTrue(result.equal(VInt(30)))
  }

  test("higher-order function") {
    val result = runPipeline("""
      def applyFunction(f: Int -> Int, value: Int): Int {
        f(value)
      }
      def square(x: Int) { x * x }
      applyFunction(square, 6)
    """)
    assertTrue(result.equal(VInt(36)))
  }

    test("higher-order function without type annotations") {
    val result = runPipeline("""
      def applyFunction(f, value) {
        f(value)
      }
      def square(x) { x * x }
      applyFunction(square, 6)
    """)
    assertTrue(result.equal(VInt(36)))
  }

  test("function with Unit type annotation") {
    val result = runPipeline("""
      def printValue(x: Int): Unit {
        val y = x + 10
      }
      printValue(5)
    """)
    assertTrue(result.equal(VUnit()))
  }
  
  test("complex program combining all features") {
    val result = runPipeline("""
      def complexFunction(a: Int, b: Int): Int {
        var result = 0
        val compute = lambda (x: Int) {
          if x < 0 then -x else x
        }
        
        var i = a
        while (i < b) {
          val valToAdd = compute(i)
          result += valToAdd
          i += 1
        }
        
        result
      }
      
      complexFunction(-3, 4)
    """)
    assertTrue(result.equal(VInt(12)))
  } 

  test("string literals and concatenation with annotation") {
    val result = runPipeline("""
      val greeting: String = "hello"
      val target: String = "world"
      val message: String = greeting + " " + target
      message
    """)
    assertTrue(result.equal(VString("hello world")))
  }

  test("double arithmetic with annotation") {
    val result = runPipeline("""
      val base: Double = 2.5 * 4.0
      val half: Double = base / 2.0
      half
    """)
    assertTrue(result.equal(VDouble(5.0)))
  }

  test("functions operating on doubles") {
    val result = runPipeline("""
      def scale(x: Double, factor: Double): Double { x * factor }
      scale(2.0, 3.0)
    """)
    assertTrue(result.equal(VDouble(6.0)))
  }

  test("functions operating on strings") {
    val result = runPipeline("""
      def greet(name: String): String { name + "!" }
      greet("Ada")
    """)
    assertTrue(result.equal(VString("Ada!")))
  }

  test("string escape sequences") {
    val result = runPipeline("""
      val text: String = "Line1\nLine2\tTabbed"
      text
    """)
    assertTrue(result.equal(VString("Line1\nLine2\tTabbed")))
  }

  test("truthy Int value in 'not'") {
    val result = runPipeline("""
      val x = not 5
      x
    """)
    assertTrue(result.equal(VBool(false)))
  }

  test("falsy Int value in 'not'") {
    val result = runPipeline("""
      val x = not 0
      x
    """)
    assertTrue(result.equal(VBool(true)))
  }

  test("truthy Double value in 'not'") {
    val result = runPipeline("""
      val x = not 3.14
      x
    """)
    assertTrue(result.equal(VBool(false)))
  }

  test("falsy Double value in 'not'") {
    val result = runPipeline("""
      val x = not 0.0
      x
    """)
    assertTrue(result.equal(VBool(true)))
  }

  test("truthy String value in 'not'") {
    val result = runPipeline("""
      val x = not "hello"
      x
    """)
    assertTrue(result.equal(VBool(false)))
  }

  test("falsy String value in 'not'") {
    val result = runPipeline("""
      val x = not ""
      x
    """)
    assertTrue(result.equal(VBool(true)))
  }

  test("truthy values in if condition") {
    val result = runPipeline("""
      def add(a, b): Int {
        a + b
      }

      if (add(2, 3)) {
        10
      } else {
        20
      }
    """)
    assertTrue(result.equal(VInt(10)))
  }

  test("truthy values in while condition") {
    val result = runPipeline("""
      var count = 3
      var sum = 0

      while (count) {
        sum += count
        count -= 1
      }

      sum
    """)
    assertTrue(result.equal(VInt(6)))
  }

}