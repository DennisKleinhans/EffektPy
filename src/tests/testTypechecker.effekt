module src/tests/testTypechecker

import test
import map
import src/lib/desugar/coreAst
import src/lib/typechecker/typecheck
import src/lib/typechecker/unification
import src/lib/utils/errors
import src/lib/utils/effects
import src/lib/utils/handlers
import src/lib/utils/helpers
import src/lib/utils/testUtils
import src/lib/utils/coreTestUtils
import src/lib/typechecker/types

def main() = mainSuite("typechecker") {

  def typeMapsEqual(actual: Map[String, TypeBinding], expected: Map[String, TypingType]): Bool = {
      
    expected.keys().all { key =>
      actual.get(key) match  {
        case Some(binding) => expected.get(key) match {
          case Some(expectedType) => binding.tpe.equal(expectedType)
          case None() => false
        }
        case None() => false
      }
    }
  }
  

  def typeMapsEqual(actual: Map[String, TypeBinding], expected: Map[String, TypeBinding]): Bool = {
      
    expected.keys().all { key =>
      actual.get(key) match  {
        case Some(v2) => expected.get(key) match {
          case Some(v1) => v1.tpe.equal(v2.tpe)
          case None() => false
        }
        case None() => false
      }
    }
  }
  

  test("typecheck simple variable declaration") {
    val prog = [
      cVal("x", None(), cLit(5))
    ]

    val progWithAnnotation = [
      cVal("x", Some(IntType()), cLit(5))
    ]

    with on[NameError].panic
    with on[TypeError].panic
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    val result = typecheck(prog)
    val resultWithAnnotation = typecheck(progWithAnnotation)

    val expected = map::fromListGeneric[String, TypingType]([
      ("x", TInt())
    ])

    assertTrue(typeMapsEqual(result, expected))
    assertTrue(typeMapsEqual(resultWithAnnotation, expected))
  }

  test("typechecker throws error on wrong type assignment") {
    val prog = [
      cVal("x", Some(BoolType()), cLit(5))
    ]

    with on[NameError].panic
    with assertThrows[TypeError]
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    typecheck(prog)
    ()
  }

  test("typechecker infers type on artithmetic expression") {
    val prog = [
      cVal("x", None(), cMult(cAdd(cLit(5), cLit(10)), cLit(2)))
    ]

    with on[NameError].panic
    with on[TypeError].panic
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    val result = typecheck(prog)

    val expected = map::fromListGeneric[String, TypingType]([
      ("x", TInt())
    ])

    assertTrue(typeMapsEqual(result, expected))
  }

  test("typechecker throws error on type mismatch in expression") {
    val prog = [
      cVal("x", None(), cAdd(cLit(5), cLit(true)))
    ]

    with on[NameError].panic
    with assertThrows[TypeError]
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    typecheck(prog)
    ()
  }

  test("typechecker throws error on assignment to immutable variable") {
    val prog = [
      cVal("x", None(), cLit(5)),
      cAssign("x", cLit(10))
    ]

    with on[NameError].panic
    with assertThrows[TypeError]
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    typecheck(prog)
    ()
  }

  test("typechecker infers types in comparison expression") {
    val prog = [
      cVal("x", None(), cLit(5)),
      cVal("y", None(), cLit(10)),
      cVal("z", None(), cEq(cV("x"), cV("y"))),
      cVal("s", None(), cLt(cV("x"), cV("y"))),
      cVal("w", None(), cLtE(cV("x"), cV("y"))),
      cVal("v", None(), cGt(cV("y"), cV("x"))),
      cVal("t", None(), cGtE(cV("y"), cV("x"))),
      cVal("u", None(), cNeq(cV("x"), cV("y")))
    ]

    with on[NameError].panic
    with on[TypeError].panic
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    val result = typecheck(prog)

    val expected = map::fromListGeneric[String, TypingType]([
      ("x", TInt()),
      ("y", TInt()),
      ("z", TBool()),
      ("s", TBool()),
      ("w", TBool()),
      ("v", TBool()),
      ("t", TBool()),
      ("u", TBool())
    ])

    assertTrue(typeMapsEqual(result, expected))
  }

  test("typechecker throws error on comparison with wrong types") {
    val prog = [
      cVal("x", None(), cLit(5)),
      cVal("y", None(), cLit(true)),
      cVal("z", None(), cEq(cV("x"), cV("y")))
    ]

    with on[NameError].panic
    with assertThrows[TypeError]
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    typecheck(prog)
    ()
  }

  test("typechecker looks up variable types correctly") {
    val prog = [
      cVal("a", None(), cLit(42)),
      cVal("b", None(), cAdd(cV("a"), cLit(8))),
      cVal("c", None(), cLit(false)),
      cVal("d", None(), cOr(cV("c"), cLit(true)))
    ]

    with on[NameError].panic
    with on[TypeError].panic
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    val result = typecheck(prog)

    val expected = map::fromListGeneric[String, TypingType]([
      ("a", TInt()),
      ("b", TInt()),
      ("c", TBool()),
      ("d", TBool())
    ])

    assertTrue(typeMapsEqual(result, expected))
  }

  test("typechecker throws error on undefined variable") {
    val prog = [
      cVal("x", None(), cAdd(cV("y"), cLit(5)))
    ]

    with on[TypeError].panic
    with assertThrows[NameError]
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    typecheck(prog)
    ()
  }

  test("typechecker reuses mutable variable types correctly") {
    val prog = [
      cVar("counter", Some(IntType()), cLit(0)),
      cAssign("counter", cAdd(cV("counter"), cLit(1))),
      cAssign("counter", cMult(cV("counter"), cLit(2)))
    ]

    with on[NameError].panic
    with on[TypeError].panic
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    val result = typecheck(prog)

    val expected = map::fromListGeneric[String, TypingType]([
      ("counter", TInt())
    ])

    assertTrue(typeMapsEqual(result, expected))
  }

  test("typechecker throws error on assigning wrong type to mutable variable") {
    val prog = [
      cVar("flag", Some(BoolType()), cLit(true)),
      cAssign("flag", cLit(10))
    ]

    with on[NameError].panic
    with assertThrows[TypeError]
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    typecheck(prog)
    ()
  }

  test("typechecker infers types in if expression") {
    val prog = [
      cVal("x", None(), cLit(5)),
      cVal("y", None(), cLit(10)),
      cVal("maxVal", None(), cIf(cLt(cV("x"), cV("y")), cV("y"), cV("x")))
    ]

    with on[NameError].panic
    with on[TypeError].panic
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    val result = typecheck(prog)

    val expected = map::fromListGeneric[String, TypingType]([
      ("x", TInt()),
      ("y", TInt()),
      ("maxVal", TInt())
    ])

    assertTrue(typeMapsEqual(result, expected))
  }

  test("typechecker throws error on if expression with wrong types") {
    val prog = [
      cVal("x", None(), cLit(true)),
      cVal("y", None(), cLit(true)),
      cVal("result", None(), cIf(cV("y"), cV("x"), cLit(10)))
    ]

    with on[NameError].panic
    with assertThrows[TypeError]
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    typecheck(prog)
    ()
  }

  test("typechecker handles nested if expressions") {
    val prog = [
      cVal("a", None(), cLit(5)),
      cVal("b", None(), cLit(10)),
      cVal("maxVal", None(), cIf(cLt(cV("a"), cV("b")),
        cIf(cGt(cV("b"), cLit(15)), cV("b"), cLit(15)),
        cV("a")))
    ]

    with on[NameError].panic
    with on[TypeError].panic
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    val result = typecheck(prog)

    val expected = map::fromListGeneric[String, TypingType]([
      ("a", TInt()),
      ("b", TInt()),
      ("maxVal", TInt())
    ])

    assertTrue(typeMapsEqual(result, expected))
  }

  test("typechecker throws error on nested if with type mismatch") {
    val prog = [
      cVal("a", None(), cLit(5)),
      cVal("b", None(), cLit(true)),
      cVal("result", None(), cIf(cV("b"),
        cIf(cLt(cV("a"), cLit(10)), cV("a"), cLit(false)),
        cLit(20)))
    ]

    with on[NameError].panic
    with assertThrows[TypeError]
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    typecheck(prog)
    ()
  }

  test("typechecker throws error on if statement with type mismatch") {
    val prog = [
      cVal("x", None(), cLit(5)),
      cVal("y", None(), cLit(10)),
      cIf(cLt(cV("x"), cV("y")),
        Block([
          cVar("z", None(), cAdd(cV("x"), cLit(true)))
        ], None()),
        Block([
          cVar("z", None(), cLt(cV("y"), cLit(2)))
        ], None())
      )
    ]

    with on[NameError].panic
    with assertThrows[TypeError]
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    typecheck(prog)
    ()
  }

  test("typechecker does not throw error on if statement with non-boolean condition since the truthiness analysis is done in the interpreter") {
    val prog = [
      cVal("x", None(), cLit(5)),
      cVal("y", None(), cLit(10)),
      cIf(cAdd(cV("x"), cV("y")),
        Block([
          cVar("z", None(), cAdd(cV("x"), cLit(2)))
        ], None()),
        Block([
          cVar("z", None(), cLt(cV("y"), cLit(2)))
        ], None())
      )
    ]

    with on[NameError].panic
    with on[TypeError].panic
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    typecheck(prog)
    ()
  }

  test("typechecker throws error on accessing variable out of scope") {
    val prog = [
      cIf(cLit(true),
        Block([
          cVar("x", None(), cLit(5))
        ], None()),
        Block([
          cVar("y", None(), cLit(10))
        ], None())
      ),
      cVal("z", None(), cAdd(cV("x"), cV("y")))
    ]

    with on[TypeError].panic
    with assertThrows[NameError]
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    typecheck(prog)
    ()
  }

  test("typechecker handles shadowing correctly") {
    val prog = [
      cVal("x", None(), cLit(5)),
      cIf(cLit(true), 
        Block([
          cVal("x", None(), cLit(true)),
          cVal("y", None(), cV("x")),
          InspectScope()
        ], None()), 
        Block(Nil(), None())),
      cVal("z", None(), cV("x"))
    ]

    val expectedInnerContext = map::fromListGeneric[String, TypeBinding]([
      ("x", TypeBinding(TBool(), false)),
      ("y", TypeBinding(TBool(), false))
    ])
    
    val expectedOuterContext = map::fromListGeneric[String, TypingType]([
      ("x", TInt()),
      ("z", TInt())
    ])

    var innerContext: Map[String, TypeBinding] = map::emptyGeneric[String, TypeBinding]()
    var outerContext: Map[String, TypeBinding] = map::emptyGeneric[String, TypeBinding]()

    with on[TypeError].panic
    with on[NameError].panic
    with mockGetPos
    try { outerContext = typecheck(prog) } with Inspector[TypeBinding] {
      def inspect(context) = {
        innerContext = context
        resume(())
      }
    }
    assertTrue(typeMapsEqual(innerContext, expectedInnerContext))
    assertTrue(typeMapsEqual(outerContext, expectedOuterContext))
  }

  test("typechecker infers types correctly in complex program") {
    val prog = [
      cVar("a", None(), cLit(10)),
      cVar("b", None(), cLit(20)),
      cVal("c", None(), cLit(true)),
      cIf(cAnd(cGt(cV("b"), cV("a")), cV("c")),
        Block([
          cVar("maxVal", None(), cV("b")),
          cAssign("a", cAdd(cV("a"), cLit(5))),
          cIf(cLt(cV("a"), cLit(25)),
            Block([
              cAssign("b", cMult(cV("b"), cLit(2)))
            ], None()),
            Block([
              cAssign("b", cSub(cV("b"), cLit(3)))
            ], None())
          )
        ], None()),
        Block([
          cVar("maxVal", None(), cV("a")),
          cAssign("b", cSub(cV("b"), cLit(5))),
          cIf(cEq(cV("b"), cLit(15)),
            Block([
              cAssign("a", cLit(15))
            ], None()),
            Block([
              cAssign("a", cAdd(cV("b"), cLit(10)))
            ], None())
          )
        ], None())
      ),
      cVal("result", None(), cMult(cAdd(cV("a"), cV("b")), cLit(2))),
      cVal("comparison", None(), cGtE(cV("result"), cLit(100)))
    ]

    with on[NameError].panic
    with on[TypeError].panic
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    val result = typecheck(prog)

    val expected = map::fromListGeneric[String, TypingType]([
      ("a", TInt()),
      ("b", TInt()),
      ("c", TBool()),
      ("result", TInt()),
      ("comparison", TBool())
    ])

    assertTrue(typeMapsEqual(result, expected))
  }

  test("typechecker handles nested if statements with shadowing") {
    val prog = [
      cVal("x", None(), cLit(5)),
      cIf(cLit(true),
        Block([
          cVal("x", None(), cLit(true)),
          cIf(cLit(false),
            Block([
              cVal("y", None(), cV("x")),
              InspectScope()
            ], None()),
            Block([
              cVal("y", None(), cLit(10)),
              InspectScope()
            ], None())
          )
        ], None()),
        Block(Nil(), None())
      ),
      cVal("z", None(), cV("x"))
    ]

    var innerContext1: Map[String, TypeBinding] = map::emptyGeneric[String, TypeBinding]()
    var innerContext2: Map[String, TypeBinding] = map::emptyGeneric[String, TypeBinding]()
    var outerContext: Map[String, TypeBinding] = map::emptyGeneric[String, TypeBinding]()
    var inspectCount = 0
    with on[TypeError].panic
    with on[NameError].panic
    with mockGetPos
    
    try { outerContext = typecheck(prog) } with Inspector[TypeBinding] {
      
      def inspect(context) = {
        if (inspectCount == 0) {
          innerContext1 = context
        } else if (inspectCount == 1) {
          innerContext2 = context
        }
        inspectCount = inspectCount + 1
        resume(())
      }
    }

    val expectedInnerContext1 = map::fromListGeneric[String, TypeBinding]([
      ("x", TypeBinding(TBool(), false)),
      ("y", TypeBinding(TBool(), false))
    ])

    val expectedInnerContext2 = map::fromListGeneric[String, TypeBinding]([
      ("x", TypeBinding(TBool(), false)),
      ("y", TypeBinding(TInt(), false))
    ])

    val expectedOuterContext = map::fromListGeneric[String, TypingType]([
      ("x", TInt()),
      ("z", TInt())
    ])

    assertTrue(typeMapsEqual(innerContext1, expectedInnerContext1))
    assertTrue(typeMapsEqual(innerContext2, expectedInnerContext2))
    assertTrue(typeMapsEqual(outerContext, expectedOuterContext))
  }

  test("typecheck while statement") {
    val prog = [
      cVar("counter", Some(IntType()), cLit(0)),
      cWhile(cLt(cV("counter"), cLit(10)),
        Block([
          cAssign("counter", cAdd(cV("counter"), cLit(1)))
        ], None())
      )
    ]

    with on[TypeError].panic
    with on[NameError].panic
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    val result = typecheck(prog)

    val expected = map::fromListGeneric[String, TypingType]([
      ("counter", TInt())
    ])

    assertTrue(typeMapsEqual(result, expected))
  }

  test("typechecker does not throw on non boolean condition in while statement since the truthiness analysis is done in the interpreter") {
    val prog = [
      cVar("counter", None(), cLit(0)),
      cWhile(cLit(5),
        Block([
          cAssign("counter", cAdd(cV("counter"), cLit(1)))
        ], None())
      )
    ]

    with on[TypeError].panic
    with on[NameError].panic
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    val result = typecheck(prog)
  }

  test("typechecker handles nested while stmt correctly") { 
    val prog = [
      cVal("x", None(), cLit(0)),
      cWhile(cLt(cV("x"), cLit(1)),
        Block([
          cVal("x", None(), cLit(true)),
          cWhile(cV("x"),
            Block([
              cVal("x", None(), cLit(10)),
              cVal("y", None(), cV("x")),
              InspectScope()
            ], None())
          ),
          InspectScope()
        ], None())
      ),
      cVal("z", None(), cAdd(cV("x"), cLit(1)))
    ]

    var innerContext1: Map[String, TypeBinding] = map::emptyGeneric[String, TypeBinding]()
    var innerContext2: Map[String, TypeBinding] = map::emptyGeneric[String, TypeBinding]()
    var outerContext: Map[String, TypeBinding] = map::emptyGeneric[String, TypeBinding]()
    var inspectCount = 0

    with on[TypeError].panic
    with on[NameError].panic
    with mockGetPos
    try { outerContext = typecheck(prog) } with Inspector[TypeBinding] {
      def inspect(context) = {
        if (inspectCount == 0) {
          innerContext1 = context
        } else if (inspectCount == 1) {
          innerContext2 = context
        }
        inspectCount = inspectCount + 1
        resume(())
      }
    }

    val expectedInnerContext1 = map::fromListGeneric[String, TypeBinding]([
      ("x", TypeBinding(TInt(), false)),
      ("y", TypeBinding(TInt(), false))
    ])

    val expectedInnerContext2 = map::fromListGeneric[String, TypeBinding]([
      ("x", TypeBinding(TBool(), false))
    ])

    val expectedOuterContext = map::fromListGeneric[String, TypingType]([
      ("x", TInt()),
      ("z", TInt())
    ])

    assertTrue(typeMapsEqual(innerContext1, expectedInnerContext1))
    assertTrue(typeMapsEqual(innerContext2, expectedInnerContext2))
    assertTrue(typeMapsEqual(outerContext, expectedOuterContext))
  }

  test("typechecker throws on break outside loop") {
    val prog = [
      cVal("x", None(), cLit(5)),
      cIf(cLt(cV("x"), cLit(10)),
        Block([
          cVar("y", None(), cLit(1)),
          cBreak()
        ], None()),
        Block([
          cVar("z", None(), cLit(2))
        ], None())
      )
    ]

    with assertThrows[TypeError]
    with on[NameError].panic
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    val result = typecheck(prog)
    ()
  }

  test("typechecker throws on continue outside loop") {
    val prog = [
      cVal("x", None(), cLit(5)),
      cIf(cLt(cV("x"), cLit(10)),
        Block([
          cVar("y", None(), cLit(1)),
          cContinue()
        ], None()),
        Block([
          cVar("z", None(), cLit(2))
        ], None())
      )
    ]

    with assertThrows[TypeError]
    with on[NameError].panic
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    val result = typecheck(prog)
    ()
  }

  test("typechecker infers types of functions") {
    val prog = [
      cVal("f", None(), cFun([Parameter("x", None(), None())], None(), Block(Nil(), Some(cAdd(cV("x"), cLit(1)))))),
      cVal("res", None(), cCall(cV("f"), [Argument(None(), cLit(10))]))
    ]

    with on[TypeError].panic
    with on[NameError].panic
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    val result = typecheck(prog)
    
    val expected = map::fromListGeneric[String, TypingType]([
      ("f", TFun([TypingParam(TInt(), false)], TInt())),
      ("res", TInt())
    ])

    assertTrue(typeMapsEqual(result, expected))
  }

  test("typechecker infers types of functions with multiple parameters") {
    val prog = [
      cVal("add", None(), cFun([Parameter("x", None(), None()), Parameter("y", None(), None())], None(), Block(Nil(), Some(cAdd(cV("x"), cV("y")))))),
      cVal("result", None(), cCall(cV("add"), [Argument(None(), cLit(5)), Argument(None(), cLit(10))]))
    ]

    with on[TypeError].panic
    with on[NameError].panic
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    val result = typecheck(prog)
    
    val expected = map::fromListGeneric[String, TypingType]([
      ("add", TFun([TypingParam(TInt(), false), TypingParam(TInt(), false)], TInt())),
      ("result", TInt())
    ])

    assertTrue(typeMapsEqual(result, expected))
  }

  test("typechecker infers boolean return type from function") {
    val prog = [
      cVal("isGreater", None(), cFun([Parameter("x", None(), None()), Parameter("y", None(), None())], None(), Block(Nil(), Some(cGt(cV("x"), cV("y")))))),
      cVal("res", None(), cCall(cV("isGreater"), [Argument(None(), cLit(10)), Argument(None(), cLit(5))]))
    ]

    with on[TypeError].panic
    with on[NameError].panic
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    val result = typecheck(prog)
    
    val expected = map::fromListGeneric[String, TypingType]([
      ("isGreater", TFun([TypingParam(TInt(), false), TypingParam(TInt(), false)], TBool())),
      ("res", TBool())
    ])

    assertTrue(typeMapsEqual(result, expected))
  }

  test("typechecker validates function with type annotations") {
    val prog = [
      cVal("f", None(), cFun([Parameter("x", Some(IntType()), None())], Some(IntType()), Block(Nil(), Some(cMult(cV("x"), cLit(2)))))),
      cVal("res", None(), cCall(cV("f"), [Argument(None(), cLit(7))]))
    ]

    with on[TypeError].panic
    with on[NameError].panic
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    val result = typecheck(prog)
    
    val expected = map::fromListGeneric[String, TypingType]([
      ("f", TFun([TypingParam(TInt(), false)], TInt())),
      ("res", TInt())
    ])

    assertTrue(typeMapsEqual(result, expected))
  }

  test("typechecker throws error on wrong return type annotation") {
    val prog = [
      cVal("f", None(), cFun([Parameter("x", None(), None())], Some(BoolType()), Block(Nil(), Some(cAdd(cV("x"), cLit(1))))))
    ]

    with on[NameError].panic
    with assertThrows[TypeError]
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    typecheck(prog)
    ()
  }

  test("typechecker throws error on wrong parameter type annotation") {
    val prog = [
      cVal("f", None(), cFun([Parameter("x", Some(BoolType()), None())], None(), Block(Nil(), Some(cAdd(cV("x"), cLit(1)))))),
      cVal("res", None(), cCall(cV("f"), [Argument(None(), cLit(true))]))
    ]

    with on[NameError].panic
    with assertThrows[TypeError]
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    typecheck(prog)
    ()
  }

  test("typechecker throws error on wrong argument type in function call") {
    val prog = [
      cVal("f", None(), cFun([Parameter("x", None(), None())], None(), Block(Nil(), Some(cAdd(cV("x"), cLit(1)))))),
      cVal("res", None(), cCall(cV("f"), [Argument(None(), cLit(true))]))
    ]

    with on[NameError].panic
    with assertThrows[TypeError]
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    typecheck(prog)
    ()
  }

  test("typechecker throws error on wrong number of arguments") {
    val prog = [
      cVal("f", None(), cFun([Parameter("x", None(), None()), Parameter("y", None(), None())], None(), Block(Nil(), Some(cAdd(cV("x"), cV("y")))))),
      cVal("res", None(), cCall(cV("f"), [Argument(None(), cLit(5))]))
    ]

    with on[NameError].panic
    with assertThrows[TypeError]
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    typecheck(prog)
    ()
  }

  test("typechecker handles nested function calls") {
    val prog = [
      cVal("double", None(), cFun([Parameter("x", None(), None())], None(), Block(Nil(), Some(cMult(cV("x"), cLit(2)))))),
      cVal("addOne", None(), cFun([Parameter("x", None(), None())], None(), Block(Nil(), Some(cAdd(cV("x"), cLit(1)))))),
      cVal("result", None(), cCall(cV("double"), [Argument(None(), cCall(cV("addOne"), [Argument(None(), cLit(5))]))]))
    ]

    with on[TypeError].panic
    with on[NameError].panic
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    val result = typecheck(prog)
    
    val expected = map::fromListGeneric[String, TypingType]([
      ("double", TFun([TypingParam(TInt(), false)], TInt())),
      ("addOne", TFun([TypingParam(TInt(), false)], TInt())),
      ("result", TInt())
    ])

    assertTrue(typeMapsEqual(result, expected))
  }

  test("typechecker throws error on type mismatch in nested function calls") {
    val prog = [
      cVal("negate", None(), cFun([Parameter("x", None(), None())], None(), Block(Nil(), Some(cNot(cV("x")))))),
      cVal("double", None(), cFun([Parameter("x", None(), None())], None(), Block(Nil(), Some(cMult(cV("x"), cLit(2)))))),
      cVal("result", None(), cCall(cV("double"), [Argument(None(), cCall(cV("negate"), [Argument(None(), cLit(true))]))]))
    ]

    with on[NameError].panic
    with assertThrows[TypeError]
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    typecheck(prog)
    ()
  }

  test("typechecker handles functions with statements in body") {
    val prog = [
      cVal("compute", None(), cFun([Parameter("x", None(), None())], None(), Block([
        cVar("temp", None(), cMult(cV("x"), cLit(2))),
        cAssign("temp", cAdd(cV("temp"), cLit(5)))
      ], Some(cV("temp"))))),
      cVal("res", None(), cCall(cV("compute"), [Argument(None(), cLit(10))]))
    ]

    with on[TypeError].panic
    with on[NameError].panic
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    val result = typecheck(prog)
    
    val expected = map::fromListGeneric[String, TypingType]([
      ("compute", TFun([TypingParam(TInt(), false)], TInt())),
      ("res", TInt())
    ])

    assertTrue(typeMapsEqual(result, expected))
  }

  test("typechecker handles functions with if expressions in body") {
    val prog = [
      cVal("maxFunc", None(), cFun([Parameter("a", None(), None()), Parameter("b", None(), None())], None(), Block(Nil(), Some(cIf(cGt(cV("a"), cV("b")), cV("a"), cV("b")))))),
      cVal("res", None(), cCall(cV("maxFunc"), [Argument(None(), cLit(15)), Argument(None(), cLit(10))]))
    ]

    with on[TypeError].panic
    with on[NameError].panic
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    val result = typecheck(prog)
    
    val expected =  map::fromListGeneric[String, TypingType]([
      ("maxFunc", TFun([TypingParam(TInt(), false), TypingParam(TInt(), false)], TInt())),
      ("res", TInt())
    ])

    assertTrue(typeMapsEqual(result, expected))
  }

  test("typechecker throws error on undefined variable in function body") {
    val prog = [
      cVal("f", None(), cFun([Parameter("x", None(), None())], None(), Block(Nil(), Some(cAdd(cV("y"), cLit(1))))))
    ]

    with on[TypeError].panic
    with assertThrows[NameError]
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    typecheck(prog)
    ()
  }

  test("typechecker handles function accessing outer scope variables") {
    val prog = [
      cVal("y", None(), cLit(10)),
      cVal("f", None(), cFun([Parameter("x", None(), None())], None(), Block(Nil(), Some(cAdd(cV("x"), cV("y")))))),
      cVal("res", None(), cCall(cV("f"), [Argument(None(), cLit(5))]))
    ]

    with on[TypeError].panic
    with on[NameError].panic
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    val result = typecheck(prog)
    
    val expected = map::fromListGeneric[String, TypingType]([
      ("y", TInt()),
      ("f", TFun([TypingParam(TInt(), false)], TInt())),
      ("res", TInt())
    ])

    assertTrue(typeMapsEqual(result, expected))
  }

  test("typechecker throws error on calling non-function value") {
    val prog = [
      cVal("x", None(), cLit(42)),
      cVal("res", None(), cCall(cV("x"), [Argument(None(), cLit(10))]))
    ]

    with on[NameError].panic
    with assertThrows[TypeError]
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    typecheck(prog)
    ()
  }

  test("typechecker handles functions with multiple statements and control flow") {
    val prog = [
      cVal("absFunc", None(), cFun([Parameter("x", None(), None())], None(), Block([
        cVar("result", None(), cV("x")),
        cIf(cLt(cV("x"), cLit(0)),
          Block([
            cAssign("result", cMult(cV("x"), cLit(-1)))
          ], None()),
          Block(Nil(), None())
        )
      ], Some(cV("result"))))),
      cVal("res", None(), cCall(cV("absFunc"), [Argument(None(), cLit(-5))]))
    ]

    with on[TypeError].panic
    with on[NameError].panic
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    val result = typecheck(prog)
    
    val expected = map::fromListGeneric[String, TypingType]([
      ("absFunc", TFun([TypingParam(TInt(), false)], TInt())),
      ("res", TInt())
    ])

    assertTrue(typeMapsEqual(result, expected))
  }

  test("typechecker handles higher-order functions returning functions") {
    val prog = [
      cVal("makeAdder", None(), cFun([Parameter("x", None(), None())], None(), Block(Nil(), Some(cFun([Parameter("y", None(), None())], None(), Block(Nil(), Some(cAdd(cV("x"), cV("y"))))))))),
      cVal("add5", None(), cCall(cV("makeAdder"), [Argument(None(), cLit(5))])),
      cVal("result", None(), cCall(cV("add5"), [Argument(None(), cLit(10))]))
    ]

    with on[TypeError].panic
    with on[NameError].panic
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    val result = typecheck(prog)
    
    val expected = map::fromListGeneric[String, TypingType]([
      ("makeAdder", TFun([TypingParam(TInt(), false)], TFun([TypingParam(TInt(), false)], TInt()))),
      ("add5", TFun([TypingParam(TInt(), false)], TInt())),
      ("result", TInt())
    ])

    assertTrue(typeMapsEqual(result, expected))
  }

  test("typechecker handles functions taking functions as arguments") {
    val prog = [
      cVal("double", None(), cFun([Parameter("x", None(), None())], None(), Block(Nil(), Some(cMult(cV("x"), cLit(2)))))),
      cVal("apply", None(), cFun([Parameter("f", None(), None()), Parameter("x", None(), None())], None(), Block(Nil(), Some(cCall(cV("f"), [Argument(None(), cV("x"))]))))),
      cVal("result", None(), cCall(cV("apply"), [Argument(None(), cV("double")), Argument(None(), cLit(5))]))
    ]

    with on[TypeError].panic
    with on[NameError].panic
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    val result = typecheck(prog)
    
    val expected = map::fromListGeneric[String, TypingType]([
      ("double", TFun([TypingParam(TInt(), false)], TInt())),
      ("apply", TFun([TypingParam(TFun([TypingParam(TInt(), false)], TInt()), false), TypingParam(TInt(), false)], TInt())),
      ("result", TInt())
    ])

    assertTrue(typeMapsEqual(result, expected))
  }

  test("typechecker handles complex nested higher-order functions") {
    val prog = [
      cVal("compose", None(), cFun([Parameter("f", None(), None()), Parameter("g", None(), None())], None(), Block(Nil(), Some(cFun([Parameter("x", None(), None())], None(), Block(Nil(), Some(cCall(cV("f"), [Argument(None(), cCall(cV("g"), [Argument(None(), cV("x"))]))])))))))),
      cVal("addOne", None(), cFun([Parameter("x", None(), None())], None(), Block(Nil(), Some(cAdd(cV("x"), cLit(1)))))),
      cVal("double", None(), cFun([Parameter("x", None(), None())], None(), Block(Nil(), Some(cMult(cV("x"), cLit(2)))))),
      cVal("combined", None(), cCall(cV("compose"), [Argument(None(), cV("double")), Argument(None(), cV("addOne"))])),
      cVal("result", None(), cCall(cV("combined"), [Argument(None(), cLit(5))]))
    ]

    with on[TypeError].panic
    with on[NameError].panic
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    val result = typecheck(prog)
    
    val expected = map::fromListGeneric[String, TypingType]([
      ("compose", TFun([TypingParam(TFun([TypingParam(TInt(), false)], TInt()), false), TypingParam(TFun([TypingParam(TInt(), false)], TInt()), false)], TFun([TypingParam(TInt(), false)], TInt()))),
      ("addOne", TFun([TypingParam(TInt(), false)], TInt())),
      ("double", TFun([TypingParam(TInt(), false)], TInt())),
      ("combined", TFun([TypingParam(TInt(), false)], TInt())),
      ("result", TInt())
    ])

    assertTrue(typeMapsEqual(result, expected))
  }

  test("typechecker handles functions with no parameters") {
    val prog = [
      cVal("getConstant", None(), cFun(Nil(), None(), Block(Nil(), Some(cLit(42))))),
      cVal("res", None(), cCall(cV("getConstant"), Nil()))
    ]

    with on[TypeError].panic
    with on[NameError].panic
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    val result = typecheck(prog)
    
    val expected = map::fromListGeneric[String, TypingType]([
      ("getConstant", TFun(Nil(), TInt())),
      ("res", TInt())
    ])

    assertTrue(typeMapsEqual(result, expected))
  }

  test("typechecker throws error when calling zero-parameter function with arguments") {
    val prog = [
      cVal("getConstant", None(), cFun(Nil(), None(), Block(Nil(), Some(cLit(42))))),
      cVal("res", None(), cCall(cV("getConstant"), [Argument(None(), cLit(5))]))
    ]

    with on[NameError].panic
    with assertThrows[TypeError]
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    typecheck(prog)
    ()
  }

  test("typechecker handles functions returning boolean with complex logic") {
    val prog = [
      cVal("inRange", None(), cFun([Parameter("x", None(), None()), Parameter("min", None(), None()), Parameter("max", None(), None())], None(), Block(Nil(), Some(cAnd(cGtE(cV("x"), cV("min")), cLtE(cV("x"), cV("max"))))))),
      cVal("res", None(), cCall(cV("inRange"), [Argument(None(), cLit(5)), Argument(None(), cLit(0)), Argument(None(), cLit(10))]))
    ]

    with on[TypeError].panic
    with on[NameError].panic
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    val result = typecheck(prog)
    
    val expected = map::fromListGeneric[String, TypingType]([
      ("inRange", TFun([TypingParam(TInt(), false), TypingParam(TInt(), false), TypingParam(TInt(), false)], TBool())),
      ("res", TBool())
    ])

    assertTrue(typeMapsEqual(result, expected))
  }

  test("typechecker handles functions with function type annotations") {
    val prog = [
      cVal("applyTwice", None(), cFun([Parameter("f", Some(FunType([IntType()], IntType())), None()), Parameter("x", Some(IntType()), None())], Some(IntType()), Block(Nil(), Some(cCall(cV("f"), [Argument(None(), cCall(cV("f"), [Argument(None(), cV("x"))]))])))))
    ]

    with on[TypeError].panic
    with on[NameError].panic
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    val result = typecheck(prog)
    
    val expected = map::fromListGeneric[String, TypingType]([
      ("applyTwice", TFun([TypingParam(TFun([TypingParam(TInt(), false)], TInt()), false), TypingParam(TInt(), false)], TInt()))
    ])

    assertTrue(typeMapsEqual(result, expected))
  }

  test("typechecker throws error on function type annotation mismatch") {
    val prog = [
      cVal("applyTwice", None(), cFun([Parameter("f", Some(FunType([BoolType()], IntType())), None()), Parameter("x", Some(IntType()), None())], Some(IntType()), Block(Nil(), Some(cCall(cV("f"), [Argument(None(), cCall(cV("f"), [Argument(None(), cV("x"))]))])))))
    ]

    with on[NameError].panic
    with assertThrows[TypeError]
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    typecheck(prog)
    ()
  }

  test("typechecker handles functions with function type annotations with multiple argument types") {
    val prog = [
      cVal("applyFunc", None(), cFun([Parameter("f", Some(FunType([IntType(), IntType()], IntType())), None()), Parameter("x", Some(IntType()), None()), Parameter("y", Some(IntType()), None())], Some(IntType()), Block(Nil(), Some(cCall(cV("f"), [Argument(None(), cV("x")), Argument(None(), cV("y"))])))))
    ]

    with on[TypeError].panic
    with on[NameError].panic
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    val result = typecheck(prog)
    
    val expected = map::fromListGeneric[String, TypingType]([
      ("applyFunc", TFun([TypingParam(TFun([TypingParam(TInt(), false), TypingParam(TInt(), false)], TInt()), false), TypingParam(TInt(), false), TypingParam(TInt(), false)], TInt()))
    ])

    assertTrue(typeMapsEqual(result, expected))
  }

  test("typechecker handles functions with multiple default arguments") {
    val prog = [
      cVal("add", None(), cFun([Parameter("x", None(), None()), Parameter("y", None(), Some(cLit(10))), Parameter("z", None(), Some(cLit(5)))], None(), Block(Nil(), Some(cAdd(cAdd(cV("x"), cV("y")), cV("z")))))),
      cVal("res1", None(), cCall(cV("add"), [Argument(None(), cLit(1)), Argument(None(), cLit(2)), Argument(None(), cLit(3))])),
      cVal("res2", None(), cCall(cV("add"), [Argument(None(), cLit(1)), Argument(None(), cLit(2))])),
      cVal("res3", None(), cCall(cV("add"), [Argument(None(), cLit(1))]))
    ]

    with on[TypeError].panic
    with on[NameError].panic
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    val result = typecheck(prog)
    
    val expected = map::fromListGeneric[String, TypingType]([
      ("add", TFun([TypingParam(TInt(), false), TypingParam(TInt(), true), TypingParam(TInt(), true)], TInt())),
      ("res1", TInt()),
      ("res2", TInt()),
      ("res3", TInt())
    ])

    assertTrue(typeMapsEqual(result, expected))
  }

  test("typechecker infers default argument types correctly") {
    val prog = [
      cVal("withDefault", None(), cFun([Parameter("x", None(), None()), Parameter("useDefault", None(), Some(cLit(true)))], None(), Block(Nil(), Some(cIf(cV("useDefault"), cLit(100), cV("x")))))),
      cVal("res", None(), cCall(cV("withDefault"), [Argument(None(), cLit(50))]))
    ]

    with on[TypeError].panic
    with on[NameError].panic
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    val result = typecheck(prog)
    
    val expected = map::fromListGeneric[String, TypingType]([
      ("withDefault", TFun([TypingParam(TInt(), false), TypingParam(TBool(), true)], TInt())),
      ("res", TInt())
    ])

    assertTrue(typeMapsEqual(result, expected))
  }

  test("typechecker throws error on type mismatch in default argument value") {
    val prog = [
      cVal("f", None(), cFun([Parameter("x", Some(IntType()), Some(cLit(true)))], None(), Block(Nil(), Some(cV("x")))))
    ]

    with on[NameError].panic
    with assertThrows[TypeError]
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    typecheck(prog)
    ()
  }

  test("typechecker throws error on wrong argument type when using default") {
    val prog = [
      cVal("f", None(), cFun([Parameter("x", None(), None()), Parameter("y", None(), Some(cLit(10)))], None(), Block(Nil(), Some(cAdd(cV("x"), cV("y")))))),
      cVal("res", None(), cCall(cV("f"), [Argument(None(), cLit(true))]))
    ]

    with on[NameError].panic
    with assertThrows[TypeError]
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    typecheck(prog)
    ()
  }

  test("typechecker validates default arguments with type annotations") {
    val prog = [
      cVal("compute", None(), cFun([Parameter("base", Some(IntType()), None()), Parameter("multiplier", Some(IntType()), Some(cLit(2))), Parameter("offset", Some(IntType()), Some(cLit(0)))], Some(IntType()), Block(Nil(), Some(cAdd(cMult(cV("base"), cV("multiplier")), cV("offset")))))),
      cVal("res", None(), cCall(cV("compute"), [Argument(None(), cLit(5))]))
    ]

    with on[TypeError].panic
    with on[NameError].panic
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    val result = typecheck(prog)
    
    val expected = map::fromListGeneric[String, TypingType]([
      ("compute", TFun([TypingParam(TInt(), false), TypingParam(TInt(), true), TypingParam(TInt(), true)], TInt())),
      ("res", TInt())
    ])

    assertTrue(typeMapsEqual(result, expected))
  }

  // String type tests
  test("typechecker infers string literal type") {
    val prog = [
      cVal("message", None(), cLit("hello"))
    ]

    with on[NameError].panic
    with on[TypeError].panic
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    val result = typecheck(prog)

    val expected = map::fromListGeneric[String, TypingType]([
      ("message", TString())
    ])

    assertTrue(typeMapsEqual(result, expected))
  }

  test("typechecker infers string concatenation type") {
    val prog = [
      cVal("hello", None(), cLit("hello")),
      cVal("world", None(), cLit("world")),
      cVal("result", None(), cAdd(cV("hello"), cV("world")))
    ]

    with on[NameError].panic
    with on[TypeError].panic
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    val result = typecheck(prog)

    val expected = map::fromListGeneric[String, TypingType]([
      ("hello", TString()),
      ("world", TString()),
      ("result", TString())
    ])

    assertTrue(typeMapsEqual(result, expected))
  }

  test("typechecker throws error on string concatenation with int") {
    val prog = [
      cVal("hello", None(), cLit("hello")),
      cVal("result", None(), cAdd(cV("hello"), cLit(42)))
    ]

    with on[NameError].panic
    with assertThrows[TypeError]
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    typecheck(prog)
    ()
  }

  test("typechecker throws error on string subtraction") {
    val prog = [
      cVal("s1", None(), cLit("hello")),
      cVal("s2", None(), cLit("world")),
      cVal("result", None(), cSub(cV("s1"), cV("s2")))
    ]

    with on[NameError].panic
    with assertThrows[TypeError]
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    typecheck(prog)
    ()
  }

  test("typechecker throws error on string comparison with <") {
    val prog = [
      cVal("s1", None(), cLit("hello")),
      cVal("s2", None(), cLit("world")),
      cVal("result", None(), cLt(cV("s1"), cV("s2")))
    ]

    with on[NameError].panic
    with assertThrows[TypeError]
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    typecheck(prog)
    ()
  }

  test("typechecker allows string equality comparison") {
    val prog = [
      cVal("s1", None(), cLit("hello")),
      cVal("s2", None(), cLit("hello")),
      cVal("result", None(), cEq(cV("s1"), cV("s2")))
    ]

    with on[NameError].panic
    with on[TypeError].panic
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    val result = typecheck(prog)

    val expected = map::fromListGeneric[String, TypingType]([
      ("s1", TString()),
      ("s2", TString()),
      ("result", TBool())
    ])

    assertTrue(typeMapsEqual(result, expected))
  }

  test("typechecker allows string inequality comparison") {
    val prog = [
      cVal("s1", None(), cLit("hello")),
      cVal("s2", None(), cLit("world")),
      cVal("result", None(), cNeq(cV("s1"), cV("s2")))
    ]

    with on[NameError].panic
    with on[TypeError].panic
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    val result = typecheck(prog)

    val expected = map::fromListGeneric[String, TypingType]([
      ("s1", TString()),
      ("s2", TString()),
      ("result", TBool())
    ])

    assertTrue(typeMapsEqual(result, expected))
  }

  test("typechecker throws error on string in arithmetic operation") {
    val prog = [
      cVal("s", None(), cLit("text")),
      cVal("result", None(), cMult(cV("s"), cLit(2)))
    ]

    with on[NameError].panic
    with assertThrows[TypeError]
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    typecheck(prog)
    ()
  }

  test("typechecker handles string function parameters") {
    val prog = [
      cVal("concat", None(), cFun([Parameter("a", Some(StringType()), None()), Parameter("b", Some(StringType()), None())], Some(StringType()), Block(Nil(), Some(cAdd(cV("a"), cV("b")))))),
      cVal("result", None(), cCall(cV("concat"), [Argument(None(), cLit("hello")), Argument(None(), cLit("world"))]))
    ]

    with on[TypeError].panic
    with on[NameError].panic
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    val result = typecheck(prog)

    val expected = map::fromListGeneric[String, TypingType]([
      ("concat", TFun([TypingParam(TString(), false), TypingParam(TString(), false)], TString())),
      ("result", TString())
    ])

    assertTrue(typeMapsEqual(result, expected))
  }

  test("typechecker throws error on mutable string variable with wrong type assignment") {
    val prog = [
      cVar("str", Some(StringType()), cLit("initial")),
      cAssign("str", cLit(42))
    ]

    with on[NameError].panic
    with assertThrows[TypeError]
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    typecheck(prog)
    ()
  }

  // Double type tests
  test("typechecker infers double literal type") {
    val prog = [
      cVal("pi", None(), cLit(3.14))
    ]

    with on[NameError].panic
    with on[TypeError].panic
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    val result = typecheck(prog)

    val expected = map::fromListGeneric[String, TypingType]([
      ("pi", TDouble())
    ])

    assertTrue(typeMapsEqual(result, expected))
  }

  test("typechecker infers double arithmetic operation type") {
    val prog = [
      cVal("x", None(), cLit(2.5)),
      cVal("y", None(), cLit(3.5)),
      cVal("sum", None(), cAdd(cV("x"), cV("y")))
    ]

    with on[NameError].panic
    with on[TypeError].panic
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    val result = typecheck(prog)

    val expected = map::fromListGeneric[String, TypingType]([
      ("x", TDouble()),
      ("y", TDouble()),
      ("sum", TDouble())
    ])

    assertTrue(typeMapsEqual(result, expected))
  }

  test("typechecker infers double subtraction type") {
    val prog = [
      cVal("a", None(), cLit(10.5)),
      cVal("b", None(), cLit(3.2)),
      cVal("diff", None(), cSub(cV("a"), cV("b")))
    ]

    with on[NameError].panic
    with on[TypeError].panic
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    val result = typecheck(prog)

    val expected = map::fromListGeneric[String, TypingType]([
      ("a", TDouble()),
      ("b", TDouble()),
      ("diff", TDouble())
    ])

    assertTrue(typeMapsEqual(result, expected))
  }

  test("typechecker infers double multiplication type") {
    val prog = [
      cVal("base", None(), cLit(2.5)),
      cVal("factor", None(), cLit(4.0)),
      cVal("product", None(), cMult(cV("base"), cV("factor")))
    ]

    with on[NameError].panic
    with on[TypeError].panic
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    val result = typecheck(prog)

    val expected = map::fromListGeneric[String, TypingType]([
      ("base", TDouble()),
      ("factor", TDouble()),
      ("product", TDouble())
    ])

    assertTrue(typeMapsEqual(result, expected))
  }

  test("typechecker infers double division type") {
    val prog = [
      cVal("dividend", None(), cLit(10.0)),
      cVal("divisor", None(), cLit(2.5)),
      cVal("quotient", None(), cDiv(cV("dividend"), cV("divisor")))
    ]

    with on[NameError].panic
    with on[TypeError].panic
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    val result = typecheck(prog)

    val expected = map::fromListGeneric[String, TypingType]([
      ("dividend", TDouble()),
      ("divisor", TDouble()),
      ("quotient", TDouble())
    ])

    assertTrue(typeMapsEqual(result, expected))
  }

  test("typechecker allows double comparison operators") {
    val prog = [
      cVal("x", None(), cLit(3.5)),
      cVal("y", None(), cLit(2.5)),
      cVal("gt", None(), cGt(cV("x"), cV("y"))),
      cVal("lt", None(), cLt(cV("x"), cV("y"))),
      cVal("eq", None(), cEq(cV("x"), cV("y"))),
      cVal("neq", None(), cNeq(cV("x"), cV("y")))
    ]

    with on[NameError].panic
    with on[TypeError].panic
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    val result = typecheck(prog)

    val expected = map::fromListGeneric[String, TypingType]([
      ("x", TDouble()),
      ("y", TDouble()),
      ("gt", TBool()),
      ("lt", TBool()),
      ("eq", TBool()),
      ("neq", TBool())
    ])

    assertTrue(typeMapsEqual(result, expected))
  }

  test("typechecker does not throw error on double in boolean operation") {
    val prog = [
      cVal("d", None(), cLit(1.5)),
      cVal("result", None(), cAnd(cV("d"), cLit(true)))
    ]

    with on[NameError].panic
    with on[TypeError].panic
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    typecheck(prog)
    ()
  }

  test("typechecker handles double function parameters") {
    val prog = [
      cVal("square", None(), cFun([Parameter("x", Some(DoubleType()), None())], Some(DoubleType()), Block(Nil(), Some(cMult(cV("x"), cV("x")))))),
      cVal("result", None(), cCall(cV("square"), [Argument(None(), cLit(2.5))]))
    ]

    with on[TypeError].panic
    with on[NameError].panic
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    val result = typecheck(prog)

    val expected = map::fromListGeneric[String, TypingType]([
      ("square", TFun([TypingParam(TDouble(), false)], TDouble())),
      ("result", TDouble())
    ])

    assertTrue(typeMapsEqual(result, expected))
  }

  test("typechecker throws error on passing int to double parameter") {
    val prog = [
      cVal("square", None(), cFun([Parameter("x", Some(DoubleType()), None())], Some(DoubleType()), Block(Nil(), Some(cMult(cV("x"), cV("x")))))),
      cVal("result", None(), cCall(cV("square"), [Argument(None(), cLit(5))]))
    ]

    with on[NameError].panic
    with assertThrows[TypeError]
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    typecheck(prog)
    ()
  }

  test("typechecker handles mutable double variables") {
    val prog = [
      cVar("value", Some(DoubleType()), cLit(1.5)),
      cAssign("value", cAdd(cV("value"), cLit(2.5))),
      cAssign("value", cMult(cV("value"), cLit(0.5)))
    ]

    with on[NameError].panic
    with on[TypeError].panic
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    val result = typecheck(prog)

    val expected = map::fromListGeneric[String, TypingType]([
      ("value", TDouble())
    ])

    assertTrue(typeMapsEqual(result, expected))
  }

  test("typechecker throws error on assigning int to double variable") {
    val prog = [
      cVar("value", Some(DoubleType()), cLit(1.5)),
      cAssign("value", cLit(10))
    ]

    with on[NameError].panic
    with assertThrows[TypeError]
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    typecheck(prog)
    ()
  }

  test("typechecker infers types in double arithmetic with if expression") {
    val prog = [
      cVal("x", None(), cLit(5.0)),
      cVal("y", None(), cLit(3.0)),
      cVal("max", None(), cIf(cGt(cV("x"), cV("y")), cV("x"), cV("y")))
    ]

    with on[NameError].panic
    with on[TypeError].panic
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    val result = typecheck(prog)

    val expected = map::fromListGeneric[String, TypingType]([
      ("x", TDouble()),
      ("y", TDouble()),
      ("max", TDouble())
    ])

    assertTrue(typeMapsEqual(result, expected))
  }

  test("typechecker handles double in while loop") {
    val prog = [
      cVar("counter", Some(DoubleType()), cLit(0.0)),
      cWhile(cLt(cV("counter"), cLit(10.0)),
        Block([
          cAssign("counter", cAdd(cV("counter"), cLit(0.5)))
        ], None())
      )
    ]

    with on[TypeError].panic
    with on[NameError].panic
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    val result = typecheck(prog)

    val expected = map::fromListGeneric[String, TypingType]([
      ("counter", TDouble())
    ])

    assertTrue(typeMapsEqual(result, expected))
  }

  test("typechecker throws on mixed arithmetic with Int and Double") {
    val prog = [cExpr(cAdd(cLit(3.0), cLit(2)))]
    
    with assertThrows[TypeError]
    with on[NameError].panic
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    typecheck(prog)
    ()
  }

  test("typechecker handles generic builtin print function") {
    val prog = [cExpr(cCall(cV("print"), [Argument(None(), cLit("Hello, world!"))]))]

    with on[TypeError].panic
    with on[NameError].panic
    with mockGetPos
    with mockInspector[Unit, TypeBinding]

    // no equality check here. Trust the typechecker to handle builtins correctly as long as no errors are raised
    val result = typecheck(prog)
  }

  test("typechecker handles 'str' function to convert some value into a string") {
    val prog = [cExpr(cAdd(cCall(cV("str"), [Argument(None(), cLit(123))]), cLit("abc")))]

    with on[TypeError].panic
    with on[NameError].panic
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    
    val result = typecheck(prog)
  }

  test("typechecker handles recursive functions") {
    val prog = [
      cVal("fact", None(), cFun([Parameter("n", None(), None())], None(), Block(Nil(), Some(
        cIf(cLtE(cV("n"), cLit(1)),
          cLit(1),
          cMult(cV("n"), cCall(cV("fact"), [Argument(None(), cSub(cV("n"), cLit(1)))]))
        )
      )))),
      cVal("res", None(), cCall(cV("fact"), [Argument(None(), cLit(5))]))
    ]

    with on[TypeError].panic
    with on[NameError].panic
    with mockGetPos
    with mockInspector[Unit, TypeBinding]
    val result = typecheck(prog)

    val expected = map::fromListGeneric[String, TypingType]([
      ("fact", TFun([TypingParam(TInt(), false)], TInt())),
      ("res", TInt())
    ])

    assertTrue(typeMapsEqual(result, expected))
  }
}