module src/lib/parser/surfaceAst

import src/lib/lexer/tokens
import src/lib/lexer/position
import src/lib/typechecker/types

type Expr {
  // literals
  IntLiteral(value: Int, pos: Position)
  BoolLiteral(value: Bool, pos: Position)
  StringLiteral(value: String, pos: Position)
  DoubleLiteral(value: Double, pos: Position)
  Variable(name: String, pos: Position)
  // binary operands
  AddExpr(left: Expr, right: Expr, pos: Position)
  SubExpr(left: Expr, right: Expr, pos: Position)
  MultExpr(left: Expr, right: Expr, pos: Position)
  DivExpr(left: Expr, right: Expr, pos: Position)
  AndExpr(left: Expr, right: Expr, pos: Position)
  OrExpr(left: Expr, right: Expr, pos: Position)
  // unary operands
  NotExpr(expr: Expr, pos: Position)
  UnaryMinus(expr: Expr, pos: Position)
  // compare operators 
  Eq(left: Expr, right: Expr, pos: Position)
  Neq(left: Expr, right: Expr, pos: Position)
  Lt(left: Expr, right: Expr, pos: Position)
  Gt(left: Expr, right: Expr, pos: Position)
  LtE(left: Expr, right: Expr, pos: Position)
  GtE(left: Expr, right: Expr, pos: Position)
  // chained comparison (preserve source structure until desugaring)
  CompareChain(first: Expr, rest: List[(TokenKind, Expr)], pos: Position)
  IfExpr(condition: Expr, thenExpr: Expr, elseExpr: Expr, pos: Position)
  // first-class functions are always an expression 
  FunExpr(params: List[Parameter], retType: Option[Type], body: Block, pos: Position)
  CallExpr(receiver: Expr, args: List[Argument], pos: Position)
}

type Stmt {
  ValDeclaration(name: String, typeAnnotation: Option[Type], value: Expr, pos: Position)
  VarDeclaration(name: String, typeAnnotation: Option[Type], value: Expr, pos: Position)
  AssignStmt(name: String, value: Expr, pos: Position)
  CompoundAssignStmt(name: String, operator: TokenKind, value: Expr, pos: Position)
  IfStmt(cond: Expr, thenBranch: Block, elseBranch: Block, pos: Position)
  ExprStmt(expr: Expr, pos: Position)
  WhileStmt(condition: Expr, body: Block, pos: Position)
  BreakStmt(pos: Position)
  ContinueStmt(pos: Position)
  DefStmt(name: String, params: List[Parameter], retType: Option[Type], body: Block, pos: Position)
  ReturnStmt(value: Option[Expr], pos: Position)
}

type Program = List[Stmt]

record Block(statements: List[Stmt], finalExpr: Option[Expr])
record Parameter(name: String, tpe: Option[Type], defaultValue: Option[Expr])
record Argument(name: Option[String], value: Expr)



