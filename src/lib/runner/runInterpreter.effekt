module src/lib/runner/runInterpreter

import map

import src/lib/shared/errors
import src/lib/shared/commonTypes
import src/lib/shared/commonEffects
import src/lib/interpreter/eval
import src/lib/interpreter/values
import src/lib/runner/result
import src/lib/runner/handlers
import src/lib/ast/coreAst


/// runs the interpreter on a desugared program, returning either a Failure with an error message or a Success with the resulting value
def runEval(prog: Program): PipelineResult[Value]  = {
  var currentPos = Position(1, 1)
  try {
    with consoleRepl
    val result = evalProgram(prog) 
    PipelineResult::Success(result)
  } with Exception[RuntimeError] {
    def raise(exception, msg) = Failure("RuntimeError: " ++ msg)
  } with Positioning {
    def getPos() = resume(currentPos)
    def setPos(p) = {
      currentPos = p
      resume(())
    }
  }
}

/// runs the interpreter incrementally on a desugared program, given an initial environment and store, returning either a Failure with an error message or a Success with the resulting EvalState
def runEvalIncremental(prog: Program, initialEnv: Map[String, Address], initialStore: Map[Address, Value]): PipelineResult[EvalState] / REPLConsole   = {
  var currentPos = Position(1, 1)
  try {
    val newEvalState = evalProgramIncremental(prog, initialEnv, initialStore) 
    PipelineResult::Success(newEvalState)
  } with Exception[RuntimeError] {
    def raise(exception, msg) = Failure("RuntimeError: " ++ msg)
  } with Positioning {
    def getPos() = resume(currentPos)
    def setPos(p) = {
      currentPos = p
      resume(())
    }
  }
}