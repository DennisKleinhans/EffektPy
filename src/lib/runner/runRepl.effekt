module src/lib/runner/runRepl

import map
import src/lib/runner/runParser
import src/lib/runner/runTypechecker
import src/lib/runner/runInterpreter
import src/lib/runner/result
import src/lib/typechecker/types
import src/lib/interpreter/values
import src/lib/utils/helpers


interface REPLConsole {
  def readLine(): String
  def writeLine(message: String): Unit
  def write(content: String): Unit
}

/// Handler for the console effect, using the Console available in js
def consoleRepl[R] { program: () => R / REPLConsole }: R = {
  val c = js::newConsole()
  try {
    val r = program()
    js::close(c)
    return r
  } with REPLConsole {
    def readLine() = resume(js::readLine(c))
    def writeLine(message) = resume(js::writeLine(c, message))
    def write(message) = resume(js::write(c, message))
  }
}

namespace js {

  extern jsNode """
    const readline = require('node:readline');
  """

  extern type JSConsole

  extern def newConsole() at io: JSConsole =
    jsNode """readline.createInterface({
        input: process.stdin,
        output: process.stdout,
      })"""

  extern def close(console: JSConsole) at io: Unit =
    jsNode "${console}.close()"

  extern def readLine(console: JSConsole) at async: String =
    jsNode "$effekt.capture(k => ${console}.once('line', k))"
  extern def writeLine(console: JSConsole, message: String) at io: Unit =
    jsNode "${console}.output.write(${message} + '\\n')"
  extern def write(console: JSConsole, message: String) at io: Unit =
    jsNode "${console}.output.write(${message})"
}



def startRepl() = {

  var typeEnv = map::emptyGeneric[String, TypeBinding]()
  var runtimeEnv = map::emptyGeneric[String, Address]()
  var store = map::emptyGeneric[Address, Value]()
  var continueRepl = true

  with consoleRepl
  do writeLine("Welcome to the EffektPy REPL!")
  do writeLine("Type ':exit' to quit.")
  
  while (continueRepl) {
    do write(">>> ")
    val line = do readLine()

    if (line == ":exit") {
      do writeLine("Goodbye!")
      continueRepl = false
      ()
    } else {
      runParsing(line) match {
        case Failure(msg) => do writeLine(msg)
        case PipelineResult::Success(ast) => {
          runTypecheckIncremental(ast, typeEnv) match {
            case Failure(msg) => do writeLine(msg)
            case PipelineResult::Success(newTypeEnv) => { 
              typeEnv = newTypeEnv
              do writeLine("Typecheck successful!")
              runEvalIncremental(ast, runtimeEnv, store) match {
                case Failure(msg) => do writeLine(msg)
                case PipelineResult::Success(evalState) => {
                  runtimeEnv = evalState.env
                  store = evalState.store
                  do writeLine("Result: " ++ evalState.value.show)
                }
              }
            }
          }
        }
      }
    }
  }
}

