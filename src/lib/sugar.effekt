import src/lib/ast
import src/lib/tokens
import src/lib/errors
import src/lib/util

/// build a list of pairwise comparison expressions from a first expression and a list of (operator, expression) pairs
def buildComparisonsFromPairs(first: Expr, pairs: List[(TokenKind, Expr)]): List[Expr] / Exception[ParseError] = {
  def go(currentLeft: Expr, remaining: List[(TokenKind, Expr)], acc: List[Expr]): List[Expr] = {
    remaining match {
      case Nil() => acc.reverse
      case Cons((op, rhs), tail) => {
        val cmp = makeCmp(op, currentLeft, rhs)
        go(rhs, tail, Cons(cmp, acc))
      }
    }
  }
  go(first, pairs, Nil())
}

/// combine a list of expressions into a chain of AndExpr
def combineWithAnd(comps: List[Expr]): Expr / Exception[DesugarError] = {
  comps match {
    case Nil() => raise(DesugarError(), "internal: combineWithAnd called with empty list") // should not happen
    case Cons(head, Nil()) => head
    case Cons(head, tail) => AndExpr(head, combineWithAnd(tail))
  }
}

/// desugar expressions by transforming syntactic sugar into core constructs
def desugarExpr(e: Expr): Expr / Exception[ParseError] = {
  e match {
    case IntLiteral(_) => e
    case BoolLiteral(_) => e
    case Variable(_) => e
    case AddExpr(l, r) => AddExpr(desugarExpr(l), desugarExpr(r))
    case SubExpr(l, r) => SubExpr(desugarExpr(l), desugarExpr(r))
    case MultExpr(l, r) => MultExpr(desugarExpr(l), desugarExpr(r))
    case DivExpr(l, r) => DivExpr(desugarExpr(l), desugarExpr(r))
    case AndExpr(l, r) => AndExpr(desugarExpr(l), desugarExpr(r))
    case OrExpr(l, r) => OrExpr(desugarExpr(l), desugarExpr(r))
    case NotExpr(inner) => NotExpr(desugarExpr(inner))
    case Eq(l, r) => Eq(desugarExpr(l), desugarExpr(r))
    case Neq(l, r) => Neq(desugarExpr(l), desugarExpr(r))
    case Lt(l, r) => Lt(desugarExpr(l), desugarExpr(r))
    case Gt(l, r) => Gt(desugarExpr(l), desugarExpr(r))
    case LtE(l, r) => LtE(desugarExpr(l), desugarExpr(r))
    case GtE(l, r) => GtE(desugarExpr(l), desugarExpr(r))
    case IfExpr(thenE, cond, elseE) => IfExpr(desugarExpr(thenE), desugarExpr(cond), desugarExpr(elseE))
    case CompareChain(first, pairs) => {
      // build pairwise comparisons then combine with AndExpr
      val comps = buildComparisonsFromPairs(first, pairs)
      if (comps is  Nil()) {
        // no pairs => just return desugared first
        desugarExpr(first)
      } else {
        // desugar subexpressions inside the comparison operands as well
        val compsDesugared = comps.map { (c) => desugarExpr(c) }
        with on[DesugarError].panic
        combineWithAnd(compsDesugared)
      }
    }
  }
}

/// desugar statements by desugaring contained expressions
def desugarStmt(s: Stmt): Stmt / Exception[ParseError] = {
  s match {
    case VariableDecl(name, tyOpt, value) => VariableDecl(name, tyOpt, desugarExpr(value))
    case IfStmt(cond, thenB, elseB) => {
      val cond2 = desugarExpr(cond)
      val then2 = thenB.map {st => desugarStmt(st)}
      val else2 = elseB.map {st => desugarStmt(st)}
      IfStmt(cond2, then2, else2)
    }
    case ExprStmt(expr) => ExprStmt(desugarExpr(expr))
  }
}

/// desugar a whole program by desugaring each statement
def desugarProgram(p: Program): Program / Exception[ParseError] = {
  p.map { s => desugarStmt(s) }
}