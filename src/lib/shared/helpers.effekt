module src/lib/shared/helpers

import map
import src/lib/shared/commonEffects
import src/lib/shared/errors
import src/lib/shared/commonTypes
import src/lib/lexer/tokens
import src/lib/lexer/effects
import src/lib/ast/surfaceAst
import src/lib/typechecker/types
import src/lib/interpreter/values


/// consume the next token and assert it has the expected kind. If not, raise a ParseError.
def expect(expected: TokenKind): Unit / { Lexer[Token], Exception[ParseError] } = {
  val token = do next()
  if (not(token.kind.equal(expected))) {
    do raise(ParseError(), "expected " ++ expected.show ++ " at Position " ++ token.position.show ++ " but got " ++ token.kind.show)
  }
}

/// consume the next token and return its LowerIdentifier id. If the token is not a LowerIdentifier, raise a ParseError.
def expectLowerIdentifier(): String / { Lexer[Token], Exception[ParseError] } = {
  val token = do next()
  token.kind match {
    case LowerIdentifier(id) => id
    case _ => do raise(ParseError(), "expected LowerIdentifier at Position " ++ token.position.show ++ " but got " ++ token.kind.show)
  }
}

/// peek at the next token and return whether it matches `kind`. This does not consume the token.
def check(kind: TokenKind) : Bool / Lexer[Token] = {
  val token = do peek()
  token.kind.equal(kind)
}

/// helper function to create comparison expressions based on the operator token
def makeCmp(op: TokenKind, left: surfaceAst::Expr, right: surfaceAst::Expr, pos: Position): surfaceAst::Expr / Exception[ParseError]  = {
  op match {
    case TokenKind::Equal() => Eq(left, right, pos)
    case NotEqual()         => Neq(left, right, pos)
    case TokenKind::Less()  => Lt(left, right, pos)
    case TokenKind::Greater() => Gt(left, right, pos)
    case LessEqual()        => LtE(left, right, pos)
    case GreaterEqual()     => GtE(left, right, pos)
    case _ => raise(ParseError(), "internal: unknown comparison operator")
  }
}

/// helper function to check whether a token kind is a comparison operator
def isComparisonOp(kind: TokenKind): Bool = {
  kind match {
    case TokenKind::Equal() => true
    case NotEqual()         => true
    case TokenKind::Less()  => true
    case TokenKind::Greater() => true
    case LessEqual()        => true
    case GreaterEqual()     => true
    case _ => false
  }
}

/// peek at the token after the next one and return whether it is an assignment
def isAssignmentFollowUp(): Bool / Lexer[Token] = {
  val nextNextToken = do peek2()
  nextNextToken.kind match {
    case Assign() => true
    case _ => false
  }
}

/// extracts a Type from a string representation. Raises ParseError if the string does not correspond to a known type.
def extractType(input: String): Type / Exception[ParseError] = {
  input match {
    case "Int" => IntType()
    case "Bool" => BoolType()
    case "Unit" => UnitType()
    case "String" => StringType()
    case "Double" => DoubleType()
    case _ => raise(ParseError(), "type annotation '" ++ input ++ "' is not a valid type")
  }
}

/// pretty prints a position
def show(pos: Position): String = "line: " ++ pos.line.show ++ " column: " ++ pos.column.show

/// pretty prints a token kind
def show(tokenKind: TokenKind): String = tokenKind match {
  case LowerIdentifier(id) => "LowerIdentifier: " ++ id
  case UpperIdentifier(id) => "UpperIdentifier: " ++ id
  case Integer(n) => "Integer: " ++ n.show
  case Boolean(b) => "Bool: " ++ b.show
  case Double(d) => "Double: " ++ d.show
  case String(s) => "String: " ++ s
  case Val() => "Keyword: val"
  case Var() => "Keyword: var"
  case If() => "Keyword: if" 
  case Else() => "Keyword: else"
  case Then() => "Keyword: then"
  case Assign() => "Operator: ="
  case TokenKind::Equal() => "Operator: =="
  case NotEqual() => "Operator: !="
  case TokenKind::Less() => "Operator: <"
  case TokenKind::Greater() => "Operator: >"
  case LessEqual() => "Operator: <="
  case GreaterEqual() => "Operator: >="
  case Plus() => "Operator: +"
  case Minus() => "Operator: -"
  case PlusAssign() => "Operator: +="
  case MinusAssign() => "Operator: -="
  case Mult() => "Operator: *"
  case Div() => "Operator: /"
  case And() => "Operator: and"
  case Or() => "Operator: or"
  case Not() => "Operator: not"
  case LParen() => "Punctuation: ("
  case RParen() => "Punctuation: )"
  case LBrace() => "Punctuation: {"
  case RBrace() => "Punctuation: }"
  case EOF() => "EndOfFile"
  case Colon() => "Colon"
  case While() => "Keyword: while"
  case Break() => "Keyword: break"
  case Continue() => "Keyword: continue"
  case Def() => "Keyword: def"
  case Return() => "Keyword: return"
  case Comma() => "Comma"
  case Lambda() => "Keyword: lambda"
  case Arrow() => "Arrow"
}

/// pretty prints a token
def show(token: Token): String = token.kind.show

/// pretty prints a typing type
def show(t: TypingType): String = t match {
  case TInt() => "Int"
  case TBool() => "Bool"
  case TUnit() => "Unit"
  case TVar(id) => "TVar(" ++ id.show ++ ")"
  case TGen(id) => "TGen(" ++ id.show ++ ")"
  case TVariadic(inner) => "TVariadic(" ++ show(inner) ++ ")"
  case TFun(params, ret) => {
    val paramStrs = params.map { p => show(p.tpe) }
    paramStrs match {
      case Nil() => "TFun() -> " ++ show(ret)
      case _ => "TFun(" ++ paramStrs.join(", ") ++ ") -> " ++ show(ret)
    }
  }
  case TString() => "String"
  case TDouble() => "Double"
}

/// pretty prints a value
def show(v: Value): String = v match {
  case VInt(n) => n.show
  case VBool(b) => b.show
  case VUnit() => "Unit"
  case VString(s) => "\"" ++ s ++ "\""
  case VDouble(d) => d.show
  case VClosure(params, body, env) => "<function>"
  case VBuiltin(name) => "<builtin function: " ++ name ++ ">"
}

/// checks if two token kinds are equal
def equal(t1: TokenKind, t2: TokenKind): Bool = (t1, t2) match {
  case (LowerIdentifier(id1), LowerIdentifier(id2)) => id1 == id2
  case (UpperIdentifier(id1), UpperIdentifier(id2)) => id1 == id2
  case (Integer(n1), Integer(n2)) => n1 == n2
  case (Boolean(b1), Boolean(b2)) => b1 == b2
  case (Double(d1), Double(d2)) => d1 == d2
  case (String(s1), String(s2)) => s1 == s2
  case (Val(), Val()) => true
  case (Var(), Var()) => true
  case (If(), If()) => true
  case (Else(), Else()) => true
  case (Then(), Then()) => true
  case (Assign(), Assign()) => true
  case (TokenKind::Equal(), TokenKind::Equal()) => true
  case (NotEqual(), NotEqual()) => true
  case (TokenKind::Less(), TokenKind::Less()) => true
  case (TokenKind::Greater(), TokenKind::Greater()) => true
  case (LessEqual(), LessEqual()) => true
  case (GreaterEqual(), GreaterEqual()) => true
  case (Plus(), Plus()) => true
  case (Minus(), Minus()) => true
  case (PlusAssign(), PlusAssign()) => true
  case (MinusAssign(), MinusAssign()) => true
  case (Mult(), Mult()) => true
  case (Div(), Div()) => true
  case (And(), And()) => true
  case (Or(), Or()) => true
  case (Not(), Not()) => true
  case (LParen(), LParen()) => true
  case (RParen(), RParen()) => true
  case (LBrace(), LBrace()) => true
  case (RBrace(), RBrace()) => true
  case (EOF(), EOF()) => true
  case (Colon(), Colon()) => true
  case (While(), While()) => true
  case (Break(), Break()) => true
  case (Continue(), Continue()) => true
  case (Return(), Return()) => true
  case (Def(), Def()) => true
  case (Comma(), Comma()) => true
  case (Lambda(), Lambda()) => true
  case (Arrow(), Arrow()) => true
  case _ => false
}

/// checks if two values are equal
def equal(v1: Value, v2: Value): Bool = (v1, v2) match {
  case (VInt(n1), VInt(n2)) => n1 == n2
  case (VBool(b1), VBool(b2)) => b1 == b2
  case (VUnit(), VUnit()) => true
  case (VString(s1), VString(s2)) => s1 == s2
  case (VDouble(d1), VDouble(d2)) => d1 == d2
  case _ => false
}

/// checks if two typing types are equal
def equal(t1: TypingType, t2: TypingType): Bool = (t1, t2) match {
  case (TInt(), TInt()) => true
  case (TBool(), TBool()) => true
  case (TVar(id1), TVar(id2)) => id1 == id2
  case (TUnit(), TUnit()) => true
  case (TString(), TString()) => true
  case (TDouble(), TDouble()) => true

  case (TFun(p1, r1), TFun(p2, r2)) => {
    if (p1.size != p2.size) {
      false 
    } else {
      val paramsEqual = p1.zip(p2).all { case (a, b) => a.tpe.equal(b.tpe) && a.isOptional == b.isOptional }
      val returnEqual = r1.equal(r2)
      paramsEqual && returnEqual
    }
  }

  case _ => false
}

/// merges two maps, with entries from the second map overwriting entries from the first in case of key conflicts
def mapUnion[K, V](m1: Map[K, V], m2: Map[K, V]): Map[K, V] = {
  var res = m1
  m2.keys().foreach { k =>
    m2.get(k) match {
      case Some(v) => res = res.put(k, v)
      case None()  => ()
    }
  }
  res
}
