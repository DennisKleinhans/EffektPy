module src/lib/parser/surfaceAst

import src/lib/lexer/tokens
import src/lib/utils/types

type Expr {
  // literals
  IntLiteral(value: Int, pos: Position)
  BoolLiteral(value: Bool, pos: Position)
  Variable(name: String, pos: Position)
  // binary operands
  AddExpr(left: Expr, right: Expr, pos: Position)
  SubExpr(left: Expr, right: Expr, pos: Position)
  MultExpr(left: Expr, right: Expr, pos: Position)
  DivExpr(left: Expr, right: Expr, pos: Position)
  AndExpr(left: Expr, right: Expr, pos: Position)
  OrExpr(left: Expr, right: Expr, pos: Position)
  // unary operands
  NotExpr(expr: Expr, pos: Position)
  UnaryMinus(expr: Expr, pos: Position)
  // compare operators 
  Eq(left: Expr, right: Expr, pos: Position)
  Neq(left: Expr, right: Expr, pos: Position)
  Lt(left: Expr, right: Expr, pos: Position)
  Gt(left: Expr, right: Expr, pos: Position)
  LtE(left: Expr, right: Expr, pos: Position)
  GtE(left: Expr, right: Expr, pos: Position)
  // chained comparison (preserve source structure until desugaring)
  CompareChain(first: Expr, rest: List[(TokenKind, Expr)], pos: Position)
  IfExpr(condition: Expr, thenExpr: Expr, elseExpr: Expr, pos: Position)
}

type Stmt {
  ValDeclaration(name: String, typeAnnotation: Option[Type], value: Expr, pos: Position)
  VarDeclaration(name: String, typeAnnotation: Option[Type], value: Expr, pos: Position)
  AssignStmt(name: String, value: Expr, pos: Position)
  CompoundAssignStmt(name: String, operator: TokenKind, value: Expr, pos: Position)
  IfStmt(cond: Expr, thenBranch: List[Stmt], elseBranch: List[Stmt], pos: Position)
  ExprStmt(expr: Expr, pos: Position)
  WhileStmt(condition: Expr, body: List[Stmt], pos: Position)
  BreakStmt(pos: Position)
  ContinueStmt(pos: Position)
}

type Program = List[Stmt]



