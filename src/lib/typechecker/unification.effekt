module src/lib/typechecker/unification

import map
import src/lib/utils/errors
import src/lib/utils/effects
import src/lib/utils/helpers
import src/lib/utils/handlers
import src/lib/typechecker/types
import src/lib/lexer/position


type Substitution = Map[Int, TypingType]

/// applies a substitution to a typing type
def applySubstitution(t: TypingType, subst: Substitution): TypingType = t match {
  case TInt() => TInt()
  case TBool() => TBool()
  case TUnit() => TUnit()
  case TVar(id) => {
    subst.get(id) match {
      case Some(t2) => applySubstitution(t2, subst)
      case None() => TVar(id)
    }
  }
  
  case TGen(id) => TGen(id)

  // recursively apply substitution to inner type
  case TVariadic(inner) => TVariadic(applySubstitution(inner, subst))

  case TFun(params, ret) => {
    val newParams = params.map { p => TypingParam(applySubstitution(p.tpe, subst), p.isOptional) }
    val newRet = applySubstitution(ret, subst)
    TFun(newParams, newRet)
  }

  case TString() => TString()
  case TDouble() => TDouble()
}

/// checks if a type variable occurs in a typing type 
def occursCheck(id: Int, t: TypingType): Bool = t match {
  case TInt() => false
  case TBool() => false
  case TUnit() => false
  case TString() => false
  case TDouble() => false
  case TGen(_) => false
  // recursively check inner type
  case TVariadic(inner) => occursCheck(id, inner)
  case TVar(otherId) => id == otherId

  case TFun(params, ret) => {
    val inParams = params.any { p => occursCheck(id, p.tpe) }
    val inRet = occursCheck(id, ret)
    inParams || inRet
  }
}

def isVariadic(t: TypingType): Bool = t match {
  case TVariadic(_) => true
  case _ => false
}

/// aligns two lists of typing parameters for unification, taking variadic parameters and optional parameters (defaults) into account
def alignParameters(p1: List[TypingParam], p2: List[TypingParam], pos: Position): List[TypeEquation] / { Exception[TypeError] } = (p1, p2) match {
  // both empty
  case (Nil(), Nil()) => Nil()

  // variadic at the end -> check rest against inner type
  case (Cons(TypingParam(TVariadic(inner), _), _), restArgs) =>
    restArgs.map { a => TypeEquation(inner, a.tpe, pos) }

  // both parameter lists have at least one element -> align heads and recurse on tails
  case (Cons(p, prest), Cons(a, arest)) =>
    Cons(TypeEquation(p.tpe, a.tpe, pos), alignParameters(prest, arest, pos))

  // definition has parameter(s) left, call has none left check if remaining definition parameters are optional
  case (remainingDef, Nil()) =>
    if (remainingDef.all { p => p.isOptional || isVariadic(p.tpe) }) Nil()
    else do raise(TypeError(), "Arity mismatch: Not enough arguments for the given signature")

  // call has parameter(s) left, definition has none left -> error
  case (Nil(), _) =>
    do raise(TypeError(), "Arity mismatch: Too many arguments for the given signature")
}

/// unification algorithm for typing types
def unify(eqs: List[TypeEquation], subst: Substitution): Substitution / { Exception[TypeError], Positioning } = {
  eqs match {
    case Nil() => subst
    case Cons(TypeEquation(left, right, pos), rest) => {
      with at(pos)
      val lNorm = applySubstitution(left, subst)
      val rNorm = applySubstitution(right, subst)
      (lNorm, rNorm) match {
        case (t1, t2) and equal(t1, t2) => unify(rest, subst)
        case (TVar(id), other) => bind(id, other, rest, subst)
        case (other, TVar(id)) => bind(id, other, rest, subst)
        case (TInt(), TInt()) => unify(rest, subst)
        case (TBool(), TBool()) => unify(rest, subst)
        case (TUnit(), TUnit()) => unify(rest, subst)
        case (TString(), TString()) => unify(rest, subst)
        case (TDouble(), TDouble()) => unify(rest, subst)

        // unify the inner types of variadic types
        case (TVariadic(inner1), TVariadic(inner2)) => {
          val newEqs = Cons(TypeEquation(inner1, inner2, pos), rest)
          unify(newEqs, subst)
        }
        
        // unify function types by unifying their return types and aligning their parameters for unification
        case (TFun(p1, r1), TFun(p2, r2)) => {
          val returnEq = TypeEquation(r1, r2, pos)

          val paramsEqs = alignParameters(p1, p2, pos)
          val newEqs = Cons(returnEq, paramsEqs.append(rest))
          unify(newEqs, subst)
        }
        case _ => do raise(TypeError(), "cannot unify types " ++ lNorm.show ++ " with " ++ rNorm.show ++ " at " ++ do getPos().show)
      }
    }
    
  }
}
  
/// helper function to bind a type variable to a typing type during unification
def bind(id: Int, t: TypingType, rest: List[TypeEquation], subst: Substitution): Substitution / { Exception[TypeError], Positioning } = {
  if (occursCheck(id, t)) {
    do raise(TypeError(), "occurs check failed for variable " ++ id.show ++ " at " ++ do getPos().show)
  } else {
    val single = map::singletonGeneric(id, t)
    val newSubst: Substitution = subst.put(id, t)
    val newRest: List[TypeEquation] =
      rest.map { case TypeEquation(l, r, pos) =>
        TypeEquation(
          applySubstitution(l, single),
          applySubstitution(r, single),
          pos
        )
      }
    unify(newRest, newSubst)
  }
}

/// solves a list of typing type equations and returns the resulting substitution
def solve(equations: List[TypeEquation]): Substitution / { Exception[TypeError], Positioning } = unify(equations, map::emptyGeneric())