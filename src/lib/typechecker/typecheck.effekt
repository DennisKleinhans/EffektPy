module src/lib/typechecker/typecheck

import map
import src/lib/desugar/coreAst
import src/lib/typechecker/unification
import src/lib/utils/errors
import src/lib/utils/effects
import src/lib/utils/helpers
import src/lib/utils/handlers
import src/lib/typechecker/types
import src/lib/lexer/position


type TypeConstraint {
  MustBeNumeric(t: TypingType, pos: Position)
  MustBeAddable(t: TypingType, pos: Position) 
}

/// effect for collecting type constraints
interface ConstraintCollector {
  def addConstraint(constraint: TypeConstraint): Unit
}

/// effect for generating fresh type variables and equating types
interface Typing {
  def fresh(): TypingType
  def equate(t1: TypingType, t2: TypingType, pos: Position): Unit
}

/// effect for getting the expected return type in a function context
interface ReturnContext {
  def getExpectedType(): TypingType
}

def getSignature(value: Expr): Option[TypingType] / Typing = value match {
  case FunExpr(params, retAnno, _, _) => {
    val pTypes = params.map { p => TypingParam(translateType(p.tpe), p.defaultValue.isDefined()) }
    val rType = translateType(retAnno)
    Some(TFun(pTypes, rType))
  }
  case _ => None()
}

def twoPassTypecheck(prog: Program): Map[String, TypeBinding] / { Exception[TypeError], Exception[NameError], Context[TypeBinding], Positioning } = {
  var equations: List[TypeEquation] = Nil()
  var constraints: List[TypeConstraint] = Nil()
  var counter = 0
  
  try {
    // first pass: predefine all variable declarations in the whole program 
    prog.foreach { 
      case ValDeclaration(name, typeAnno, value, _) => {
        val sig = getSignature(value) match {
          case Some(t) => t
          case None() => translateType(typeAnno)
        }
        // predefine all val declarations as immutable
        do define(name, TypeBinding(sig, false))
      }
      case VarDeclaration(name, typeAnno, value, _) => {
        val sig = getSignature(value) match {
          case Some(t) => t
          case None() => translateType(typeAnno)
        }
        // predefine all var declarations as mutable
        do define(name, TypeBinding(sig, true))
      }
      case _ => ()
    }

    // second pass: typecheck all statements
    prog.foreach { stmt => checkStmt(stmt); () }
    

    val finalSubst = solve(equations.reverse())

    constraints.foreach { 
      case MustBeNumeric(t, pos) => {
        val concrete = applySubstitution(t, finalSubst)
        validateIsNumeric(concrete, pos)
      }

      case MustBeAddable(t, pos) => {
        val concrete = applySubstitution(t, finalSubst)
        concrete match {
          case TInt() => ()
          case TString() => ()
          case TDouble() => ()
          case _ => raise(TypeError(), "Addition requires String, Int, or Double, but got " ++ concrete.show ++ " at " ++ pos.show)
        }
      }
    }

    val currentEnv: Map[String, TypeBinding] = do backup()
    var updatedEnv = map::emptyGeneric[String, TypeBinding]()

    currentEnv.foreach { (name, binding) => {
        val concreteType = applySubstitution(binding.tpe, finalSubst)
        updatedEnv = updatedEnv.put(name, TypeBinding(concreteType, binding.isMutable))
      }
    }
    updatedEnv

  } with Typing {
    def fresh() = {
      val t = TVar(counter)
      counter = counter + 1
      resume(t)
    }

    def equate(t1: TypingType, t2: TypingType, pos) = {
      equations = Cons(TypeEquation(t1, t2, pos), equations)
      resume(())
    }
  } with ConstraintCollector {
    def addConstraint(constraint: TypeConstraint) = {
      constraints = Cons(constraint, constraints)
      resume(())
    }
  } with LoopContext {
    def isInLoop() = resume(false)
  } with ReturnContext {
    def getExpectedType() = raise(TypeError(), "Return statement outside of function context")
  }
}

// typechecks a program and returns a mapping from variable names to their inferred types
def typecheck(prog: Program): Map[String, TypeBinding] / { Exception[TypeError], Exception[NameError], Positioning } = {
  with handleTypingContext(getBuiltinTypeEnv())
  twoPassTypecheck(prog)
}

/// typechecks a program and returns a mapping from variable names to their inferred types
/// accepts an initial environment of variable bindings to start from
def typecheckIncremental(prog: Program, initialEnv: Map[String, TypeBinding]): Map[String, TypeBinding] / { Exception[TypeError], Exception[NameError], Positioning } = {
  
  // extend the initial environment with built-in functions
  // prefers initialEnv bindings in case of name clashes results in builtins being overridden
  val newInitialEnv = getBuiltinTypeEnv().mapUnion(initialEnv)

  with handleTypingContext(initialEnv)
  twoPassTypecheck(prog)
  
}

/// typecheck a single statement
def checkStmt(stmt: Stmt): TypingType / { Typing, Context[TypeBinding], Exception[TypeError], Positioning, LoopContext, ReturnContext, ConstraintCollector } = stmt match {
  case ValDeclaration(name, typeAnno, value, pos) => {
    with at(pos) 
    // just lookup the predefined binding 
    val binding = do lookup(name)
    val tExpr = checkExpr(value)
    do equate(tExpr, binding.tpe, pos)
    TUnit()
  }

  case VarDeclaration(name, typeAnno, value, pos) => {
    with at(pos) 
    // just lookup the predefined binding 
    val binding = do lookup(name)
    val tExpr = checkExpr(value)
    do equate(tExpr, binding.tpe, pos)
    TUnit()
  }

  case AssignStmt(name, value, pos) => {
    with at(pos) 
    val binding = do lookup(name)
    if (not(binding.isMutable)) {
      raise[Unit, TypeError](TypeError(), "Cannot assign to immutable variable '" ++ name ++ "' at " ++ do getPos().show)
    }
    do equate(binding.tpe, checkExpr(value), pos)
    TUnit()
  }

  case IfStmt(cond, thenBranch, elseBranch, pos) => {
    with at(pos) 
    // check the condition but don't enforce its type to be boolean yet. The truthiness analysis is done in the interpreter.
    checkExpr(cond)
    checkBlock(thenBranch) 
    checkBlock(elseBranch) 
  }

  case ExprStmt(expr, pos) => {
    with at(pos) 
    checkExpr(expr)
    TUnit()
  }

  case WhileStmt(condition, body, pos) => {
    with at(pos) 
    // check the condition but don't enforce its type to be boolean yet. The truthiness analysis is done in the interpreter.
    checkExpr(condition)

    with handleNewTypingScope
    try {
      checkBlock(body)
    } with LoopContext {
      def isInLoop() = resume(true)
    }
    TUnit()
  }

  case BreakStmt(pos) => {
    if (not(do isInLoop())) {
      raise(TypeError(), "'break' is only allowed inside a loop " ++ pos.show)
    }
    TUnit()
  }

  case ContinueStmt(pos) => {
    if (not(do isInLoop())) {
      raise(TypeError(), "'continue' is only allowed inside a loop " ++ pos.show)
    }
    TUnit()
  }

  case ReturnStmt(maybeExpr, pos) => {
    with at(pos)
    val expectedType = do getExpectedType()

    val actualType = maybeExpr match {
      case Some(expr) => checkExpr(expr)
      case None() => TUnit()
    }

    do equate(actualType, expectedType, pos)
    TUnit()
  }
}

def checkBlock(block: Block): TypingType / { Typing, Context[TypeBinding], Exception[TypeError], Positioning, LoopContext, ReturnContext, ConstraintCollector } = {

  with handleNewTypingScope
  // fist pass: predefine all variable declarations in the block
  block.statements.foreach { 
    case ValDeclaration(name, typeAnno, value, _) => {
      val sig = getSignature(value) match {
        case Some(t) => t
        case None() => translateType(typeAnno)
      }
      // predefine all val declarations as immutable
      do define(name, TypeBinding(sig, false))
    }
    case VarDeclaration(name, typeAnno, value, _) => {
      val sig = getSignature(value) match {
        case Some(t) => t
        case None() => translateType(typeAnno)
      }
      // predefine all var declarations as mutable
      do define(name, TypeBinding(sig, true))
    }
    case _ => ()
  }
  
  // second pass: typecheck all statements in the block
  block.statements.foreach { stmt => checkStmt(stmt); () }
  block.finalExpr match {
    case Some(expr) => checkExpr(expr)
    case None() => TUnit()
  }
}

/// Typecheck an expression and return its inferred type
def checkExpr(expr: Expr): TypingType / { Typing, Context[TypeBinding], Positioning, Exception[TypeError], LoopContext, ConstraintCollector } = expr match {
  case IntLiteral(value, pos) => { with at(pos); TInt()}
  case BoolLiteral(value, pos) => { with at(pos); TBool()}
  case StringLiteral(value, pos) => { with at(pos); TString()}
  case DoubleLiteral(value, pos) => { with at(pos); TDouble()}
  case Variable(name, pos) => {
    with at(pos) 
    val binding = do lookup(name)
    binding.tpe
  }

  case AddExpr(left, right, pos) => {
    with at(pos) 
    val tLeft = checkExpr(left)
    val tRight = checkExpr(right)

    do equate(tLeft, tRight, pos)
    do addConstraint(MustBeAddable(tLeft, pos))
    tLeft
  }
  
  case SubExpr(left, right, pos) => {
    with at(pos) 
    checkNumeric(left, right, pos)
  }

  case MultExpr(left, right, pos) => {
    with at(pos) 
    checkNumeric(left, right, pos)
  }

  case DivExpr(left, right, pos) => {
    with at(pos) 
    checkNumeric(left, right, pos)
  }

  case IfExpr(condition, thenExpr, elseExpr, pos) => {
    with at(pos) 
    // check the condition but don't enforce its type to be boolean yet. The truthiness analysis is done in the interpreter.
    val tCond = checkExpr(condition)
    val tThen = checkExpr(thenExpr)
    val tElse = checkExpr(elseExpr)
    
    do equate(tThen, tElse, pos)
    tThen
  }

  case AndExpr(left, right, pos) => {
    with at(pos) 
    // check both sides but don't enforce their types to be boolean yet. The truthiness analysis is done in the interpreter.
    val tLeft = checkExpr(left)
    val tRight = checkExpr(right)
    TBool()
  }

  case OrExpr(left, right, pos) => {
    with at(pos) 
    // check both sides but don't enforce their types to be boolean yet. The truthiness analysis is done in the interpreter.
    val tLeft = checkExpr(left)
    val tRight = checkExpr(right)
    TBool()
  }

  case NotExpr(inner, pos) => {
    with at(pos) 
    // check the condition but don't enforce its type to be boolean yet. The truthiness analysis is done in the interpreter.
    checkExpr(inner)
    TBool()
  }

  case Eq(left, right, pos) => {
    with at(pos) 
    val tLeft = checkExpr(left)
    val tRight = checkExpr(right)
    do equate(tLeft, tRight, pos)
    TBool()
  }

  case Neq(left, right, pos) => {
    with at(pos) 
    val tLeft = checkExpr(left)
    val tRight = checkExpr(right)
    do equate(tLeft, tRight, pos)
    TBool()
  }

  case Lt(left, right, pos) => {
    with at(pos) 
    checkNumeric(left, right, pos)
    TBool()
  }

  case Gt(left, right, pos) => {
    with at(pos) 
    checkNumeric(left, right, pos)
    TBool()
  }

  case LtE(left, right, pos) => {
    with at(pos) 
    checkNumeric(left, right, pos)
    TBool()
  }

  case GtE(left, right, pos) => {
    with at(pos) 
    checkNumeric(left, right, pos)
    TBool()
  }

  case FunExpr(params, retAnno, body, pos) => {
    with at(pos) 
    val paramTypes = params.map { p => 
      val pType = translateType(p.tpe)

      // validate default value if present
      p.defaultValue match {
        case Some(defaultExpr) => {
          val tDefault = checkExpr(defaultExpr)
          // make sure default value matches parameter type
          do equate(tDefault, pType, pos)
        }
        case None() => ()
      } 
      TypingParam(pType, p.defaultValue.isDefined())
    }

    val retType = translateType(retAnno)

    handleNewTypingScope {
      params.zip(paramTypes).foreach { case (p, tp) => 
        do define(p.name, TypeBinding(tp.tpe, false))
      }
      
      val tBody = try {
        checkBlock(body)
      } with ReturnContext {
        def getExpectedType() = resume(retType)
      }
      
      // if the body has a final expression, ensure its type matches the declared return type
      if (body.finalExpr.isDefined()) {
        do equate(tBody, retType, pos)
      } 
    }
    TFun(paramTypes, retType)
  }

  case CallExpr(receiver, args, pos) => {
    with at(pos) 

    receiver match {
      // special case for 'print' to allow any argument types and arbitrary number of arguments
      case Variable("print", _) => {
        args.foreach { arg => checkExpr(arg.value); () }
        TUnit()
      } 

      case Variable(name, _) and name == "max" || name == "min" => {
        if (args.size < 2) {
          raise(TypeError(), "'" ++ name ++ "' requires at least two arguments at " ++ pos.show)
        }

        val memberType = instantiate(TGen(0)) 

        args.foreach { arg => {
          val tArg = checkExpr(arg.value)
          assertIsNumeric(tArg, pos)
          do equate(tArg, memberType, pos)
        } }
        memberType
      }

      case _ => {
        val tReceiver = instantiate(checkExpr(receiver))
        val retType = do fresh()

        // Wir bauen einen "Call-Typ" aus den Argumenten
        // Wichtig: Argumente im Aufruf sind fÃ¼r den Unifizierer nie "optional"
        val argTypes = args.map { arg => TypingParam(checkExpr(arg.value), false) }
        val tCall = TFun(argTypes, retType)
        
        // Das Alignment passiert jetzt automatisch in unify
        do equate(tReceiver, tCall, pos)
        retType
      }
    }
  }
}

/// check that both sides are numeric types and return the resulting type
def checkNumeric(left: Expr, right: Expr, pos: Position): TypingType / { Typing, Context[TypeBinding], Positioning, Exception[TypeError], LoopContext, ConstraintCollector } = {
  val tLeft = checkExpr(left)
  val tRight = checkExpr(right)

  assertIsNumeric(tLeft, pos)
  assertIsNumeric(tRight, pos)

  do equate(tLeft, tRight, pos)
  tLeft
}

/// assert that a type is numeric (int or double)
def assertIsNumeric(t: TypingType, pos: Position): Unit / { Typing, Positioning, Exception[TypeError], ConstraintCollector } = t match {
  case TInt() => ()
  case TDouble() => ()
  case TVar(_) => do addConstraint(MustBeNumeric(t, pos)) // add a constraint to be checked later
  case _ => raise(TypeError(), "Expected numeric type, but got " ++ t.show ++ " at " ++ pos.show)
}

def validateIsNumeric(t: TypingType, pos: Position): Unit / { Exception[TypeError], Positioning } = t match {
  case TInt() => ()
  case TDouble() => ()
  case _ => raise(TypeError(), "Expected numeric type, but got " ++ t.show ++ " at " ++ pos.show)
}

/// translate an optional Type annotation into a TypingType
def translateType(t: Option[Type]): TypingType / Typing = t match {
  case Some(IntType()) => TInt()
  case Some(BoolType()) => TBool()
  case Some(UnitType()) => TUnit()

  case Some(FunType(paramTypes, returnType)) => {
    val tParams = paramTypes.map { pt => TypingParam(translateType(Some(pt)), false) }
    val tReturn = translateType(Some(returnType))
    TFun(tParams, tReturn)
  }

  case Some(StringType()) => TString()
  case Some(DoubleType()) => TDouble()

  case None() => do fresh() // generate a fresh type variable
}

/// instantiate a type by replacing all negative type variables with fresh type variables
def instantiate(t: TypingType): TypingType / Typing = {
  // mapping from generic type variable ids to fresh type variables
  var mapping = map::emptyGeneric[Int, TypingType]()

  def go(tp: TypingType): TypingType / Typing = tp match {
    // replace generic type variables with fresh type variables
    case TGen(id) => {
      mapping.get(id) match {
        case Some(freshT) => freshT
        case None() => {
          val freshT = do fresh()
          mapping = mapping.put(id, freshT)
          freshT
        }
      }
    }

    // recursively instantiate inner type
    case TVariadic(inner) => TVariadic(go(inner))

    // recursively instantiate function parameter and return types
    case TFun(paramTypes, retType) => {
      TFun(paramTypes.map { p => TypingParam(go(p.tpe), p.isOptional) }, go(retType))
    }
    case _ => tp
  }
  go(t)
}

/// constructs the built-in type environment
def getBuiltinTypeEnv(): Map[String, TypeBinding] = {
  map::fromListGeneric[String, TypeBinding]([
    // here TVar(-1) represents a generic type parameter which gets instantiated upon use
    ("print", TypeBinding(TFun([TypingParam(TVariadic(TGen(0)), false)], TUnit()), false)),
    ("input", TypeBinding(TFun([TypingParam(TString(), true)], TString()), false)),
    ("str", TypeBinding(TFun([TypingParam(TGen(0), false)], TString()), false)),
    ("max", TypeBinding(TFun([
        TypingParam(TGen(0), false), // first Arg
        TypingParam(TGen(0), false), // second Arg
        TypingParam(TVariadic(TGen(0)), false) // variadic Args
      ], TGen(0)), false)),
    ("min", TypeBinding(TFun([
        TypingParam(TGen(0), false), // first Arg
        TypingParam(TGen(0), false), // second Arg
        TypingParam(TVariadic(TGen(0)), false) // variadic Args
      ], TGen(0)), false))
  ])
}
