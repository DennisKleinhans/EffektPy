import src/lib/desugar/coreAst
import src/lib/utils/types
import src/lib/utils/effects
import src/lib/utils/handlers
import src/lib/utils/errors

def evalExpr(expr: Expr): Value / { Context[Address], Store, Exception[RuntimeError]} = expr match {
  case IntLiteral(n) => VInt(n)
  case BoolLiteral(b) => VBool(b)
  case Variable(name) => { 
    val addr = do lookup(name)
    do load(addr)
  }
  case AddExpr(left, right) => {
    val vLeft = evalExpr(left)
    val vRight = evalExpr(right)
    (vLeft, vRight) match {
      case (VInt(l), VInt(r)) => VInt(l + r)
      case _ => do raise(errors::RuntimeError(), "Type error in addition")
    }
  }
  case SubExpr(left, right) => {
    val vLeft = evalExpr(left)
    val vRight = evalExpr(right)
    (vLeft, vRight) match {
      case (VInt(l), VInt(r)) => VInt(l - r)
      case _ => do raise(errors::RuntimeError(), "Type error in subtraction")
    }
  }
  case MultExpr(left, right) => {
    val vLeft = evalExpr(left)
    val vRight = evalExpr(right)
    (vLeft, vRight) match {
      case (VInt(l), VInt(r)) => VInt(l * r)
      case _ => do raise(errors::RuntimeError(), "Type error in multiplication")
    }
  }
  case DivExpr(left, right) => {
    val vLeft = evalExpr(left)
    val vRight = evalExpr(right)
    (vLeft, vRight) match {
      case (VInt(l), VInt(r)) => 
        if (r != 0) {
          VInt(l / r)
        } else {
          do raise(errors::RuntimeError(), "Division by zero")
        }
      case _ => do raise(errors::RuntimeError(), "Type error in division")
    }
  }
  
  case IfExpr(condition, thenExpr, elseExpr) => {
    val vCond = evalExpr(condition)
    vCond match {
      case VBool(cond) =>
        if (cond) {
          evalExpr(thenExpr)
        } else {
          evalExpr(elseExpr)
        }
      case _ => do raise(errors::RuntimeError(), "Type error in if condition")}
  }
  case AndExpr(left, right) => {
    val vLeft = evalExpr(left)
    val vRight = evalExpr(right)
    (vLeft, vRight) match {
      case (VBool(l), VBool(r)) => VBool(l && r)
      case _ => do raise(errors::RuntimeError(), "Type error in logical and")
    }
  }
  case OrExpr(left, right) => {
    val vLeft = evalExpr(left)
    val vRight = evalExpr(right)
    (vLeft, vRight) match {
      case (VBool(l), VBool(r)) => VBool(l || r)
      case _ => do raise(errors::RuntimeError(), "Type error in logical or")
    }
  }
  case NotExpr(inner) => {
    val vInner   = evalExpr(inner)
    vInner match {
      case VBool(b) => VBool(not(b))
      case _ => do raise(errors::RuntimeError(), "Type error in logical not")
    }
  }
  case Eq(left, right) => {
    val vLeft = evalExpr(left)
    val vRight = evalExpr(right)
    (vLeft, vRight) match {
      case (VInt(l), VInt(r)) => VBool(l == r)
      case (VBool(l), VBool(r)) => VBool(l == r)
      case _ => do raise(errors::RuntimeError(), "Type error in equality comparison")
    }
  }
  case Neq(left, right) => {
    val vLeft = evalExpr(left)
    val vRight = evalExpr(right)
    (vLeft, vRight) match {
      case (VInt(l), VInt(r)) => VBool(l != r)
      case (VBool(l), VBool(r)) => VBool(l != r)
      case _ => do raise(errors::RuntimeError(), "Type error in inequality comparison")
    }
  }
  case Lt(left, right) => {
    val vLeft = evalExpr(left)
    val vRight = evalExpr(right)
    (vLeft, vRight) match {
      case (VInt(l), VInt(r)) => VBool(l < r)
      case _ => do raise(errors::RuntimeError(), "Type error in less-than comparison")
    }
  }
  case Gt(left, right) => {
    val vLeft = evalExpr(left)
    val vRight = evalExpr(right)
    (vLeft, vRight) match {
      case (VInt(l), VInt(r)) => VBool(l > r)
      case _ => do raise(errors::RuntimeError(), "Type error in greater-than comparison")
    }
  }
  case LtE(left, right) => {
    val vLeft = evalExpr(left)
    val vRight = evalExpr(right)
    (vLeft, vRight) match {
      case (VInt(l), VInt(r)) => VBool(l <= r)
      case _ => do raise(errors::RuntimeError(), "Type error in less-than-equal comparison")
    }
  }
  case GtE(left, right) => {
    val vLeft = evalExpr(left)
    val vRight = evalExpr(right)
    (vLeft, vRight) match {
      case (VInt(l), VInt(r)) => VBool(l >= r)
      case _ => do raise(errors::RuntimeError(), "Type error in greater-than-equal comparison")
    }
  }
}

def evalStmt(stmt: Stmt): Value / { Context[Address], Store, Exception[RuntimeError], Inspector[Address] } = stmt match {
  case ValDeclaration(name, _, value) => {
    val v = evalExpr(value)
    val addr = do allocate(v)
    do define(name, addr)
    VUnit()
  }
  case VarDeclaration(name, _, value) => {
    val v = evalExpr(value)
    val addr = do allocate(v)
    do define(name, addr)
    VUnit() 
  }
  case AssignStmt(name, value) => {
    // no additional mutability check here; assume typechecker has done its job
    val newValue = evalExpr(value)
    val addr = do lookup(name)
    do store(addr, newValue)
    VUnit()
  }
  case IfStmt(cond, thenBranch, elseBranch) => {
    val vCond = evalExpr(cond)
    vCond match {
      case VBool(b) => if (b) evalBlock(thenBranch) else evalBlock(elseBranch)
      case _ => do raise(errors::RuntimeError(), "Type error in if condition")
    }
  }
  case ExprStmt(expr) => {
    evalExpr(expr)
  }
  case InspectScope() => {
    val currentContext = do backup()
    do inspect(currentContext)
    VUnit()
  }
}

def evalBlock(stmts: List[Stmt]): Value / { Context[Address], Store, Exception[RuntimeError], Inspector[Address] } = {
  var lastValue = VUnit()
  with handleNewRuntimeScope
  stmts.foreach { stmt => lastValue = evalStmt(stmt) }
  lastValue
}

def evalProgram(program: Program): Value / { Exception[RuntimeError], Inspector[Address], getPos} = {
  with handleRuntimeContext
  evalBlock(program)
}