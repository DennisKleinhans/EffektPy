module src/lib/interpreter/eval

import map
import src/lib/desugar/coreAst
import src/lib/utils/effects
import src/lib/utils/handlers
import src/lib/utils/errors
import src/lib/utils/helpers
import src/lib/interpreter/values
import src/lib/lexer/position
import src/lib/runner/result


/// Determines the truthiness of a value (python-like semantics)
def isTruthy(value: Value): Value = value match {
  case VBool(b) => VBool(b)
  case VInt(n) => VBool(n != 0)
  case VDouble(d) => VBool(d != 0.0)
  case VString(s) => VBool(s != "")
  case _ => VBool(false)
}

/// Converts a value to its string representation
def stringify(value: Value): String = value match {
  case VInt(n) => n.show
  case VDouble(d) => d.show
  case VBool(b) => b.show
  case VString(s) => s
  case VUnit() => "unit"
  case VClosure(_, _, _) => "<function>"
  case VBuiltin(name) => "<builtin function: " ++ name ++ ">"
}

/// evaluates an expression and returns the resulting value
def evalExpr(expr: Expr): Value / { Context[Address], Store, Exception[RuntimeError], Positioning, LoopControl, REPLConsole } = expr match {
  case IntLiteral(n, pos) => { 
    with at(pos)
    VInt(n) 
  }

  case BoolLiteral(b, pos) => { 
    with at(pos)
    VBool(b) 
  }

  case DoubleLiteral(d, pos) => {
    with at(pos)
    VDouble(d)
  }

  case StringLiteral(s, pos) => {
    with at(pos)
    VString(s)
  }

  case Variable(name, pos) => { 
    with at(pos)
    val addr = do lookup(name)
    do load(addr)
  }

  case AddExpr(left, right, pos) => {
    with at(pos)
   val (vLeft, vRight) = (evalExpr(left), evalExpr(right))
    (vLeft, vRight) match {
      case (VInt(l), VInt(r)) => VInt(l + r)
      case (VDouble(l), VDouble(r)) => VDouble(l + r)
      case (VString(l), VString(r)) => VString(l ++ r) // string concatenation
      case _ => do raise(errors::RuntimeError(), "Type error in addition")
    }
  }

  case SubExpr(left, right, pos) => {
    with at(pos)
    val (vLeft, vRight) = (evalExpr(left), evalExpr(right))
    (vLeft, vRight) match {
      case (VInt(l), VInt(r)) => VInt(l - r)
      case (VDouble(l), VDouble(r)) => VDouble(l - r)
      case _ => do raise(errors::RuntimeError(), "Type error in subtraction")
    }
  }

  case MultExpr(left, right, pos) => {
    with at(pos)
    val (vLeft, vRight) = (evalExpr(left), evalExpr(right))
    (vLeft, vRight) match {
      case (VInt(l), VInt(r)) => VInt(l * r)
      case (VDouble(l), VDouble(r)) => VDouble(l * r)
      case _ => do raise(errors::RuntimeError(), "Type error in multiplication")
    }
  }

  case DivExpr(left, right, pos) => {
    with at(pos)
    val (vLeft, vRight) = (evalExpr(left), evalExpr(right))
    (vLeft, vRight) match {
      case (VInt(l), VInt(r)) => {
        if (r != 0) {
          VInt(l / r)
        } else {
          do raise(errors::RuntimeError(), "Division by zero at " ++ do getPos().show)
        }
      }
      case (VDouble(l), VDouble(r)) => {
        if (r != 0.0) {
          VDouble(l / r)
        } else {
          do raise(errors::RuntimeError(), "Division by zero at " ++ do getPos().show)
        }
      }
      case _ => do raise(errors::RuntimeError(), "Type error in division")
    }
  }
  
  case IfExpr(condition, thenExpr, elseExpr, pos) => {
    with at(pos)
    val vCond = isTruthy(evalExpr(condition))
    vCond match {
      case VBool(cond) =>
        if (cond) {
          evalExpr(thenExpr)
        } else {
          evalExpr(elseExpr)
        }
      case _ => do raise(errors::RuntimeError(), "Type error in if condition")}
  }

  case AndExpr(left, right, pos) => {
    with at(pos)

    isTruthy(evalExpr(left)) match {
      case VBool(false) => VBool(false) // short-circuit
      case VBool(true) => {
        val vRight = isTruthy(evalExpr(right))
        vRight match {
          case VBool(r) => VBool(r)
          case _ => do raise(errors::RuntimeError(), "Type error in logical and")
        }
      }
      case _ => do raise(errors::RuntimeError(), "Type error in logical and")
    }
  }

  case OrExpr(left, right, pos) => {
    with at(pos)
    val vLeft = isTruthy(evalExpr(left))
    val vRight = isTruthy(evalExpr(right))
    (vLeft, vRight) match {
      case (VBool(l), VBool(r)) => VBool(l || r)
      case _ => do raise(errors::RuntimeError(), "Type error in logical or")
    }
  }

  case NotExpr(inner, pos) => {
    with at(pos)
    val vInner = isTruthy(evalExpr(inner))
    vInner match {
      case VBool(b) => VBool(not(b))
      case _ => do raise(errors::RuntimeError(), "Type error in logical not")
    }
  }

  case Eq(left, right, pos) => {
    with at(pos)
    val (vLeft, vRight) = (evalExpr(left), evalExpr(right))
    (vLeft, vRight) match {
      case (VInt(l), VInt(r)) => VBool(l == r)
      case (VDouble(l), VDouble(r)) => VBool(l == r)
      case (VString(l), VString(r)) => VBool(l == r)
      case (VBool(l), VBool(r)) => VBool(l == r)
      case (VUnit(), VUnit()) => VBool(true)
      case _ => do raise(errors::RuntimeError(), "Type error in equality comparison")
    }
  }

  case Neq(left, right, pos) => {
    with at(pos)
    val (vLeft, vRight) = (evalExpr(left), evalExpr(right))
    (vLeft, vRight) match {
      case (VInt(l), VInt(r)) => VBool(l != r)
      case (VBool(l), VBool(r)) => VBool(l != r)
      case (VDouble(l), VDouble(r)) => VBool(l != r)
      case (VString(l), VString(r)) => VBool(l != r)
      case _ => do raise(errors::RuntimeError(), "Type error in inequality comparison")
    }
  }

  case Lt(left, right, pos) => {
    with at(pos)
    val (vLeft, vRight) = (evalExpr(left), evalExpr(right))
    (vLeft, vRight) match {
      case (VInt(l), VInt(r)) => VBool(l < r)
      case (VDouble(l), VDouble(r)) => VBool(l < r)
      case _ => do raise(errors::RuntimeError(), "Type error in less-than comparison")
    }
  }

  case Gt(left, right, pos) => {
    with at(pos)
    val (vLeft, vRight) = (evalExpr(left), evalExpr(right))
    (vLeft, vRight) match {
      case (VInt(l), VInt(r)) => VBool(l > r)
      case (VDouble(l), VDouble(r)) => VBool(l > r)
      case _ => do raise(errors::RuntimeError(), "Type error in greater-than comparison")
    }
  }

  case LtE(left, right, pos) => {
    with at(pos)
    val (vLeft, vRight) = (evalExpr(left), evalExpr(right))
    (vLeft, vRight) match {
      case (VInt(l), VInt(r)) => VBool(l <= r)
      case (VDouble(l), VDouble(r)) => VBool(l <= r)
      case _ => do raise(errors::RuntimeError(), "Type error in less-than-equal comparison")
    }
  }

  case GtE(left, right, pos) => {
    with at(pos)
    val (vLeft, vRight) = (evalExpr(left), evalExpr(right))
    (vLeft, vRight) match {
      case (VInt(l), VInt(r)) => VBool(l >= r)
      case (VDouble(l), VDouble(r)) => VBool(l >= r)
      case _ => do raise(errors::RuntimeError(), "Type error in greater-than-equal comparison")
    }
  }

  case FunExpr(params, _, body, pos) => {
    with at(pos)
    val capturedEnv = do backup()
    VClosure(params, body, capturedEnv)
  }

  case CallExpr(receiver, args, pos) => {
    with at(pos)
    val vFunc = evalExpr(receiver)
    val evaluatedArgs = args.map { arg => (arg.name, evalExpr(arg.value)) }

    vFunc match {
      case VBuiltin(name) => {
        val argValues = evaluatedArgs.map { case (_, value) => value }
        name match {
          case "print" => {
            val output = argValues.map { v => stringify(v) }.join(" ")
            println(output)
            VUnit()
          }

          case "input" => {
            if (argValues.size > 1) {
              raise(errors::RuntimeError(), "input() takes at most one argument")
            } else {
              argValues.headOption match {
                case Some(promptValue) => {
                  promptValue match {
                    case VString(prompt) => do writeSingle(prompt)
                    case _ => raise(errors::RuntimeError(), "input() argument must be a string")
                  }
                }
                case None() => ()
              }
            }
            val line = do readLine()
            VString(line)
          }

          case "str" => {
            argValues.headOption match {
              case Some(valueToConvert) => {
                VString(stringify(valueToConvert))
              }
              case None() => raise(errors::RuntimeError(), "str() takes exactly one argument")
            }
          }

          case "max" => {
            val values = evaluatedArgs.map { case (_, v) => v }
            with on[MissingValue].default{VInt(0)}
            values.tail.foldLeft(values.head) { (currentMax, nextValue) =>
              (currentMax, nextValue) match {
                case (VInt(i1), VInt(i2)) => VInt(max(i1, i2))
                case (VDouble(d1), VDouble(d2)) => VDouble(max(d1, d2))
                case _ => raise(errors::RuntimeError(), "max() arguments must be all of the same numeric type")
              }
            }
          }

          case "min" => {
            val values = evaluatedArgs.map { case (_, v) => v }
            with on[MissingValue].default{VInt(0)}
            values.tail.foldLeft(values.head) { (currentMin, nextValue) =>
              (currentMin, nextValue) match {
                case (VInt(i1), VInt(i2)) => VInt(min(i1, i2))
                case (VDouble(d1), VDouble(d2)) => VDouble(min(d1, d2))
                case _ => raise(errors::RuntimeError(), "min() arguments must be all of the same numeric type")
              }
            }
          }

          case _ => raise(errors::RuntimeError(), "Unknown builtin function: " ++ name)
        }
      }

      case VClosure(params, body, capturedEnv) => {
        var assignments = map::emptyGeneric[String, Value]
        var positionalIndex = 0

        // assign arguments to parameters
        evaluatedArgs.foreach { case (maybeName, value) => 
          maybeName match {
            // positional argument
            case None() => {
              if (positionalIndex >= params.size) {
                raise(errors::RuntimeError(), "Too many arguments provided. Expected " ++ params.size.show)
              }
              with on[OutOfBounds].panic
              val param = params.get(positionalIndex)

              // check for duplicate assignment
              if (assignments.contains(param.name)) {
                raise(errors::RuntimeError(), "Parameter '" ++ param.name ++ "' is assigned twice.")
              }

              assignments = assignments.put(param.name, value)
              positionalIndex = positionalIndex + 1
            }
            // named argument
            case Some(name) => {
              val paramExists = params.any { p => p.name == name }
              if (not(paramExists)) {
                raise(errors::RuntimeError(), "Unknown argument name: " ++ name)
              }
              // check for duplicate assignment
              if (assignments.contains(name)) {
                raise(errors::RuntimeError(), "Parameter '" ++ name ++ "' is assigned twice.")
              }

              assignments = assignments.put(name, value)
            }
          }
        }

        try {
          with handleRuntimeContext(capturedEnv)
          with handleNewRuntimeScope
          
          params.foreach { p => 
            val valToAssign = assignments.get(p.name) match {
              case None() => p.defaultValue match {
                case Some(defVal) => evalExpr(defVal)
                case None() => raise(errors::RuntimeError(), "Missing argument for parameter: " ++ p.name)
              }
              
              case Some(v) => v
            }
            val addr = do allocate(valToAssign)
            do define(p.name, addr)
          }

          evalBlock(body)
        } with ReturnControl {
          def returnValue(value) = value
        }
       
      }

      case _ => raise(errors::RuntimeError(), "trying to call a non-function value at " ++ pos.show)
    }
  }
}

/// evaluates a statement and returns the resulting value
def evalStmt(stmt: Stmt): Value / { Context[Address], Store, Exception[RuntimeError], Positioning, LoopControl, ReturnControl, REPLConsole } = stmt match {
  case ValDeclaration(name, _, value, pos) => {
    with at(pos)
    // just lookup the predefined binding
    val v = evalExpr(value)
    val addr = do lookup(name)
    do store(addr, v)
    VUnit()
  }

  case VarDeclaration(name, _, value, pos) => {
    with at(pos)
    // just lookup the predefined binding
    val v = evalExpr(value)
    val addr = do lookup(name)
    do store(addr, v)
    VUnit()
  }

  case AssignStmt(name, value, pos) => {
    with at(pos)
    // no additional mutability check here; assume typechecker has done its job
    val newValue = evalExpr(value)
    val addr = do lookup(name)
    do store(addr, newValue)
    VUnit()
  }

  case IfStmt(cond, thenBranch, elseBranch, pos) => {
    with at(pos)
    val vCond = isTruthy(evalExpr(cond))
    vCond match {
      case VBool(b) => if (b) evalBlock(thenBranch) else evalBlock(elseBranch)
      case _ => do raise(errors::RuntimeError(), "Type error in if condition")
    }
  }

  case ExprStmt(expr, pos) => {
    with at(pos)
    evalExpr(expr)
  }

  case WhileStmt(condition, body, pos) => {
    with at(pos)
    
    def runLoop(): Unit = {
      var vCond = isTruthy(evalExpr(condition))
      var cond = vCond match {
        case VBool(b) => b
        case _ => false
      }
      if (cond) {
        try {
          evalBlock(body)
          runLoop()
        } with LoopControl {
          def breakLoop() = ()
          def continueLoop() = runLoop()
        }
      } else {
        ()
      }
    }
    runLoop()
    VUnit()
  }

  case BreakStmt(pos) => {
    with at(pos)
    do breakLoop()
    VUnit()
  }

  case ContinueStmt(pos) => {
    with at(pos)
    do continueLoop()
    VUnit()
  }
  
  case ReturnStmt(maybeExpr, pos) => {
    with at(pos)
    val returnVal = maybeExpr match {
      case Some(expr) => evalExpr(expr)
      case None() => VUnit()
    }
    do returnValue(returnVal)
    VUnit() // unreachable
  }
}

/// evaluates a block of statements and returns the resulting value
def evalBlock(block: Block): Value / { Context[Address], Store, Exception[RuntimeError], Positioning, LoopControl, ReturnControl, REPLConsole } = {
  with handleNewRuntimeScope
  // first pass: predefine all variable declarations in the block
  block.statements.foreach {
    case ValDeclaration(name, _, _, _) => {
      val addr = do allocate(VUnit())
      do define(name, addr)
    }
    case VarDeclaration(name, _, _, _) => {
      val addr = do allocate(VUnit())
      do define(name, addr)
    }
    case _ => ()
  }
  
  // second pass: evaluate all statements in the block
  var lastValue = VUnit()
  block.statements.foreach { stmt => lastValue = evalStmt(stmt) }

  block.finalExpr match {
    case Some(expr) => evalExpr(expr)
    case None() => lastValue
  }
  
}

/// evaluates a program and returns the resulting value
def evalProgram(program: Program): Value / { Exception[RuntimeError], Positioning, REPLConsole } = {
  evalProgramIncremental(program, map::emptyGeneric[String, Address](), map::emptyGeneric[Address, Value]()).value
}

/// evaluates a program incrementally, given an initial environment and store, returning the resulting EvalState
def evalProgramIncremental(program: Program, initialEnv: Map[String, Address], initialStore: Map[Address, Value]): EvalState / { Exception[RuntimeError], Positioning, REPLConsole } = {
  with handleDefaultLoopControl
  with handleStore(initialStore)
  val newInitialEnv = getInitialEvalEnv().mapUnion(initialEnv)
  with handleRuntimeContext(newInitialEnv)
  
  try {
    // first pass: predefine all variable declarations in the whole program by allocating addresses with a placeholder value (VUnit)
    program.foreach {
      case ValDeclaration(name, _, _, _) => {
        val addr = do allocate(VUnit())
        do define(name, addr)
      }
      case VarDeclaration(name, _, _, _) => {
        val addr = do allocate(VUnit())
        do define(name, addr)
      }
      case _ => ()
    }

    // second pass: evaluate all statements in the program
    var lastValue = VUnit()
    program.foreach { stmt => 
      lastValue = evalStmt(stmt) 
    }
    val finalEnv = do backup()
    val finalStore = do dump()
    EvalState(lastValue, finalEnv, finalStore)
  } with ReturnControl {
    def returnValue(value) = EvalState(value, do backup(), do dump())
  }
}

/// constructs the initial evaluation environment with built-in functions
def getInitialEvalEnv(): Map[String, Address] / Store = {
  var env = map::emptyGeneric[String, Address]
  val builtins = ["print", "input", "str", "max", "min"]

  builtins.foreach { name => 
    val addr = do allocate(VBuiltin(name))
    env = env.put(name, addr)  
  }
  env
}
