module src/lib/interpreter/eval

import map
import src/lib/desugar/coreAst
import src/lib/utils/effects
import src/lib/utils/handlers
import src/lib/utils/errors
import src/lib/utils/helpers
import src/lib/interpreter/values
import src/lib/lexer/position


def evalExpr(expr: Expr): Value / { Context[Address], Store, Exception[RuntimeError], Positioning, Inspector[Address], LoopControl } = expr match {
  case IntLiteral(n, pos) => { 
    with at(pos)
    VInt(n) 
  }

  case BoolLiteral(b, pos) => { 
    with at(pos)
    VBool(b) 
  }

  case Variable(name, pos) => { 
    with at(pos)
    val addr = do lookup(name)
    do load(addr)
  }

  case AddExpr(left, right, pos) => {
    with at(pos)
    val vLeft = evalExpr(left)
    val vRight = evalExpr(right)
    (vLeft, vRight) match {
      case (VInt(l), VInt(r)) => VInt(l + r)
      case _ => do raise(errors::RuntimeError(), "Type error in addition")
    }
  }

  case SubExpr(left, right, pos) => {
    with at(pos)
    val vLeft = evalExpr(left)
    val vRight = evalExpr(right)
    (vLeft, vRight) match {
      case (VInt(l), VInt(r)) => VInt(l - r)
      case _ => do raise(errors::RuntimeError(), "Type error in subtraction")
    }
  }

  case MultExpr(left, right, pos) => {
    with at(pos)
    val vLeft = evalExpr(left)
    val vRight = evalExpr(right)
    (vLeft, vRight) match {
      case (VInt(l), VInt(r)) => VInt(l * r)
      case _ => do raise(errors::RuntimeError(), "Type error in multiplication")
    }
  }

  case DivExpr(left, right, pos) => {
    with at(pos)
    val vLeft = evalExpr(left)
    val vRight = evalExpr(right)
    (vLeft, vRight) match {
      case (VInt(l), VInt(r)) => 
        if (r != 0) {
          VInt(l / r)
        } else {
          do raise(errors::RuntimeError(), "Division by zero at " ++ do getPos().show)
        }
      case _ => do raise(errors::RuntimeError(), "Type error in division")
    }
  }
  
  case IfExpr(condition, thenExpr, elseExpr, pos) => {
    with at(pos)
    val vCond = evalExpr(condition)
    vCond match {
      case VBool(cond) =>
        if (cond) {
          evalExpr(thenExpr)
        } else {
          evalExpr(elseExpr)
        }
      case _ => do raise(errors::RuntimeError(), "Type error in if condition")}
  }

  case AndExpr(left, right, pos) => {
    with at(pos)
    val vLeft = evalExpr(left)
    val vRight = evalExpr(right)
    (vLeft, vRight) match {
      case (VBool(l), VBool(r)) => VBool(l && r)
      case _ => do raise(errors::RuntimeError(), "Type error in logical and")
    }
  }

  case OrExpr(left, right, pos) => {
    with at(pos)
    val vLeft = evalExpr(left)
    val vRight = evalExpr(right)
    (vLeft, vRight) match {
      case (VBool(l), VBool(r)) => VBool(l || r)
      case _ => do raise(errors::RuntimeError(), "Type error in logical or")
    }
  }

  case NotExpr(inner, pos) => {
    with at(pos)
    val vInner   = evalExpr(inner)
    vInner match {
      case VBool(b) => VBool(not(b))
      case _ => do raise(errors::RuntimeError(), "Type error in logical not")
    }
  }

  case Eq(left, right, pos) => {
    with at(pos)
    val vLeft = evalExpr(left)
    val vRight = evalExpr(right)
    (vLeft, vRight) match {
      case (VInt(l), VInt(r)) => VBool(l == r)
      case (VBool(l), VBool(r)) => VBool(l == r)
      case _ => do raise(errors::RuntimeError(), "Type error in equality comparison")
    }
  }

  case Neq(left, right, pos) => {
    with at(pos)
    val vLeft = evalExpr(left)
    val vRight = evalExpr(right)
    (vLeft, vRight) match {
      case (VInt(l), VInt(r)) => VBool(l != r)
      case (VBool(l), VBool(r)) => VBool(l != r)
      case _ => do raise(errors::RuntimeError(), "Type error in inequality comparison")
    }
  }

  case Lt(left, right, pos) => {
    with at(pos)
    val vLeft = evalExpr(left)
    val vRight = evalExpr(right)
    (vLeft, vRight) match {
      case (VInt(l), VInt(r)) => VBool(l < r)
      case _ => do raise(errors::RuntimeError(), "Type error in less-than comparison")
    }
  }

  case Gt(left, right, pos) => {
    with at(pos)
    val vLeft = evalExpr(left)
    val vRight = evalExpr(right)
    (vLeft, vRight) match {
      case (VInt(l), VInt(r)) => VBool(l > r)
      case _ => do raise(errors::RuntimeError(), "Type error in greater-than comparison")
    }
  }

  case LtE(left, right, pos) => {
    with at(pos)
    val vLeft = evalExpr(left)
    val vRight = evalExpr(right)
    (vLeft, vRight) match {
      case (VInt(l), VInt(r)) => VBool(l <= r)
      case _ => do raise(errors::RuntimeError(), "Type error in less-than-equal comparison")
    }
  }

  case GtE(left, right, pos) => {
    with at(pos)
    val vLeft = evalExpr(left)
    val vRight = evalExpr(right)
    (vLeft, vRight) match {
      case (VInt(l), VInt(r)) => VBool(l >= r)
      case _ => do raise(errors::RuntimeError(), "Type error in greater-than-equal comparison")
    }
  }

  case FunExpr(params, _, body, pos) => {
    with at(pos)
    val capturedEnv = do backup()
    VClosure(params, body, capturedEnv)
  }

  case CallExpr(receiver, args, pos) => {
    with at(pos)
    val vFunc = evalExpr(receiver)
    val evaluatedArgs = args.map { arg => (arg.name, evalExpr(arg.value)) }

    vFunc match {
      case VClosure(params, body, capturedEnv) => {
        var assignments = map::emptyGeneric[String, Value]
        var positionalIndex = 0

        // assign arguments to parameters
        evaluatedArgs.foreach { case (maybeName, value) => 
          maybeName match {
            // positional argument
            case None() => {
              if (positionalIndex >= params.size) {
                raise(errors::RuntimeError(), "Too many arguments provided. Expected " ++ params.size.show)
              }
              with on[OutOfBounds].panic
              val param = params.get(positionalIndex)

              // check for duplicate assignment
              if (assignments.contains(param.name)) {
                raise(errors::RuntimeError(), "Parameter '" ++ param.name ++ "' is assigned twice.")
              }

              assignments = assignments.put(param.name, value)
              positionalIndex = positionalIndex + 1
            }
            // named argument
            case Some(name) => {
              val paramExists = params.any { p => p.name == name }
              if (not(paramExists)) {
                raise(errors::RuntimeError(), "Unknown argument name: " ++ name)
              }
              // check for duplicate assignment
              if (assignments.contains(name)) {
                raise(errors::RuntimeError(), "Parameter '" ++ name ++ "' is assigned twice.")
              }

              assignments = assignments.put(name, value)
            }
          }
        }

        try {
          with handleRuntimeContext(Some(capturedEnv))
          with handleNewRuntimeScope
          
          params.foreach { p => 
            val valToAssign = assignments.get(p.name) match {
              case None() => p.defaultValue match {
                case Some(defVal) => evalExpr(defVal)
                case None() => raise(errors::RuntimeError(), "Missing argument for parameter: " ++ p.name)
              }
              
              case Some(v) => v
            }
            val addr = do allocate(valToAssign)
            do define(p.name, addr)
          }

          evalBlock(body)
        } with ReturnControl {
          def returnValue(value) = value
        }
       
      }

      case _ => raise(errors::RuntimeError(), "trying to call a non-function value at " ++ pos.show)
    }
  }
}

def evalStmt(stmt: Stmt): Value / { Context[Address], Store, Exception[RuntimeError], Inspector[Address], Positioning, LoopControl, ReturnControl } = stmt match {
  case ValDeclaration(name, _, value, pos) => {
    with at(pos)
    val v = evalExpr(value)
    val addr = do allocate(v)
    do define(name, addr)
    VUnit()
  }

  case VarDeclaration(name, _, value, pos) => {
    with at(pos)
    val v = evalExpr(value)
    val addr = do allocate(v)
    do define(name, addr)
    VUnit() 
  }

  case AssignStmt(name, value, pos) => {
    with at(pos)
    // no additional mutability check here; assume typechecker has done its job
    val newValue = evalExpr(value)
    val addr = do lookup(name)
    do store(addr, newValue)
    VUnit()
  }

  case IfStmt(cond, thenBranch, elseBranch, pos) => {
    with at(pos)
    val vCond = evalExpr(cond)
    vCond match {
      case VBool(b) => if (b) evalBlock(thenBranch) else evalBlock(elseBranch)
      case _ => do raise(errors::RuntimeError(), "Type error in if condition")
    }
  }

  case ExprStmt(expr, pos) => {
    with at(pos)
    evalExpr(expr)
  }

  case WhileStmt(condition, body, pos) => {
    with at(pos)
    
    def runLoop(): Unit = {
      var vCond = evalExpr(condition)
      var cond = vCond match {
        case VBool(b) => b
        case _ => false
      }
      if (cond) {
        try {
          evalBlock(body)
          runLoop()
        } with LoopControl {
          def breakLoop() = ()
          def continueLoop() = runLoop()
        }
      } else {
        ()
      }
    }
    runLoop()
    VUnit()
  }

  case BreakStmt(pos) => {
    with at(pos)
    do breakLoop()
    VUnit()
  }

  case ContinueStmt(pos) => {
    with at(pos)
    do continueLoop()
    VUnit()
  }

  case InspectScope() => {
    val currentContext = do backup()
    do inspect(currentContext)
    VUnit()
  }
  
  case ReturnStmt(maybeExpr, pos) => {
    with at(pos)
    val returnVal = maybeExpr match {
      case Some(expr) => evalExpr(expr)
      case None() => VUnit()
    }
    do returnValue(returnVal)
    VUnit() // unreachable
  }
}

def evalBlock(block: Block): Value / { Context[Address], Store, Exception[RuntimeError], Inspector[Address], Positioning, LoopControl, ReturnControl } = {
  var lastValue = VUnit()
  with handleNewRuntimeScope
  block.statements.foreach { stmt => lastValue = evalStmt(stmt) }

  block.finalExpr match {
    case Some(expr) => evalExpr(expr)
    case None() => lastValue
  }
  
}

def evalProgram(program: Program): Value / { Exception[RuntimeError], Inspector[Address], Positioning } = {
  with handleDefaultLoopControl
  with handleStore
  with handleRuntimeContext(None())
  
  try {
    var lastValue = VUnit()
    program.foreach { stmt => 
      lastValue = evalStmt(stmt) 
    }

    lastValue
  } with ReturnControl {
    def returnValue(value) = value
  }
  
}