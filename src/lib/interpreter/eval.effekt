module src/lib/interpreter/eval

import src/lib/desugar/coreAst
import src/lib/utils/types
import src/lib/utils/effects
import src/lib/utils/handlers
import src/lib/utils/errors
import src/lib/utils/helpers

def evalExpr(expr: Expr): Value / { Context[Address], Store, Exception[RuntimeError], Positioning } = expr match {
  case IntLiteral(n, pos) => { 
    with at(pos)
    VInt(n) 
  }

  case BoolLiteral(b, pos) => { 
    with at(pos)
    VBool(b) 
  }

  case Variable(name, pos) => { 
    with at(pos)
    val addr = do lookup(name)
    do load(addr)
  }

  case AddExpr(left, right, pos) => {
    with at(pos)
    val vLeft = evalExpr(left)
    val vRight = evalExpr(right)
    (vLeft, vRight) match {
      case (VInt(l), VInt(r)) => VInt(l + r)
      case _ => do raise(errors::RuntimeError(), "Type error in addition")
    }
  }

  case SubExpr(left, right, pos) => {
    with at(pos)
    val vLeft = evalExpr(left)
    val vRight = evalExpr(right)
    (vLeft, vRight) match {
      case (VInt(l), VInt(r)) => VInt(l - r)
      case _ => do raise(errors::RuntimeError(), "Type error in subtraction")
    }
  }

  case MultExpr(left, right, pos) => {
    with at(pos)
    val vLeft = evalExpr(left)
    val vRight = evalExpr(right)
    (vLeft, vRight) match {
      case (VInt(l), VInt(r)) => VInt(l * r)
      case _ => do raise(errors::RuntimeError(), "Type error in multiplication")
    }
  }

  case DivExpr(left, right, pos) => {
    with at(pos)
    val vLeft = evalExpr(left)
    val vRight = evalExpr(right)
    (vLeft, vRight) match {
      case (VInt(l), VInt(r)) => 
        if (r != 0) {
          VInt(l / r)
        } else {
          do raise(errors::RuntimeError(), "Division by zero at " ++ do getPos().show)
        }
      case _ => do raise(errors::RuntimeError(), "Type error in division")
    }
  }
  
  case IfExpr(condition, thenExpr, elseExpr, pos) => {
    with at(pos)
    val vCond = evalExpr(condition)
    vCond match {
      case VBool(cond) =>
        if (cond) {
          evalExpr(thenExpr)
        } else {
          evalExpr(elseExpr)
        }
      case _ => do raise(errors::RuntimeError(), "Type error in if condition")}
  }

  case AndExpr(left, right, pos) => {
    with at(pos)
    val vLeft = evalExpr(left)
    val vRight = evalExpr(right)
    (vLeft, vRight) match {
      case (VBool(l), VBool(r)) => VBool(l && r)
      case _ => do raise(errors::RuntimeError(), "Type error in logical and")
    }
  }

  case OrExpr(left, right, pos) => {
    with at(pos)
    val vLeft = evalExpr(left)
    val vRight = evalExpr(right)
    (vLeft, vRight) match {
      case (VBool(l), VBool(r)) => VBool(l || r)
      case _ => do raise(errors::RuntimeError(), "Type error in logical or")
    }
  }

  case NotExpr(inner, pos) => {
    with at(pos)
    val vInner   = evalExpr(inner)
    vInner match {
      case VBool(b) => VBool(not(b))
      case _ => do raise(errors::RuntimeError(), "Type error in logical not")
    }
  }

  case Eq(left, right, pos) => {
    with at(pos)
    val vLeft = evalExpr(left)
    val vRight = evalExpr(right)
    (vLeft, vRight) match {
      case (VInt(l), VInt(r)) => VBool(l == r)
      case (VBool(l), VBool(r)) => VBool(l == r)
      case _ => do raise(errors::RuntimeError(), "Type error in equality comparison")
    }
  }

  case Neq(left, right, pos) => {
    with at(pos)
    val vLeft = evalExpr(left)
    val vRight = evalExpr(right)
    (vLeft, vRight) match {
      case (VInt(l), VInt(r)) => VBool(l != r)
      case (VBool(l), VBool(r)) => VBool(l != r)
      case _ => do raise(errors::RuntimeError(), "Type error in inequality comparison")
    }
  }

  case Lt(left, right, pos) => {
    with at(pos)
    val vLeft = evalExpr(left)
    val vRight = evalExpr(right)
    (vLeft, vRight) match {
      case (VInt(l), VInt(r)) => VBool(l < r)
      case _ => do raise(errors::RuntimeError(), "Type error in less-than comparison")
    }
  }

  case Gt(left, right, pos) => {
    with at(pos)
    val vLeft = evalExpr(left)
    val vRight = evalExpr(right)
    (vLeft, vRight) match {
      case (VInt(l), VInt(r)) => VBool(l > r)
      case _ => do raise(errors::RuntimeError(), "Type error in greater-than comparison")
    }
  }

  case LtE(left, right, pos) => {
    with at(pos)
    val vLeft = evalExpr(left)
    val vRight = evalExpr(right)
    (vLeft, vRight) match {
      case (VInt(l), VInt(r)) => VBool(l <= r)
      case _ => do raise(errors::RuntimeError(), "Type error in less-than-equal comparison")
    }
  }

  case GtE(left, right, pos) => {
    with at(pos)
    val vLeft = evalExpr(left)
    val vRight = evalExpr(right)
    (vLeft, vRight) match {
      case (VInt(l), VInt(r)) => VBool(l >= r)
      case _ => do raise(errors::RuntimeError(), "Type error in greater-than-equal comparison")
    }
  }
}

def evalStmt(stmt: Stmt): Value / { Context[Address], Store, Exception[RuntimeError], Inspector[Address], Positioning, LoopControl } = stmt match {
  case ValDeclaration(name, _, value, pos) => {
    with at(pos)
    val v = evalExpr(value)
    val addr = do allocate(v)
    do define(name, addr)
    VUnit()
  }

  case VarDeclaration(name, _, value, pos) => {
    with at(pos)
    val v = evalExpr(value)
    val addr = do allocate(v)
    do define(name, addr)
    VUnit() 
  }

  case AssignStmt(name, value, pos) => {
    with at(pos)
    // no additional mutability check here; assume typechecker has done its job
    val newValue = evalExpr(value)
    val addr = do lookup(name)
    do store(addr, newValue)
    VUnit()
  }

  case IfStmt(cond, thenBranch, elseBranch, pos) => {
    with at(pos)
    val vCond = evalExpr(cond)
    vCond match {
      case VBool(b) => if (b) evalBlock(thenBranch) else evalBlock(elseBranch)
      case _ => do raise(errors::RuntimeError(), "Type error in if condition")
    }
  }

  case ExprStmt(expr, pos) => {
    with at(pos)
    evalExpr(expr)
  }

  case WhileStmt(condition, body, pos) => {
    with at(pos)
    
    def runLoop(): Unit = {
      var vCond = evalExpr(condition)
      var cond = vCond match {
        case VBool(b) => b
        case _ => false
      }
      if (cond) {
        try {
          evalBlock(body)
          runLoop()
        } with LoopControl {
          def breakLoop() = ()
          def continueLoop() = runLoop()
        }
      } else {
        ()
      }
    }
    runLoop()
    VUnit()
  }

  case BreakStmt(pos) => {
    with at(pos)
    do breakLoop()
    VUnit()
  }

  case ContinueStmt(pos) => {
    with at(pos)
    do continueLoop()
    VUnit()
  }

  case InspectScope() => {
    val currentContext = do backup()
    do inspect(currentContext)
    VUnit()
  }
}

def evalBlock(stmts: List[Stmt]): Value / { Context[Address], Store, Exception[RuntimeError], Inspector[Address], Positioning, LoopControl } = {
  var lastValue = VUnit()
  with handleNewRuntimeScope
  stmts.foreach { stmt => lastValue = evalStmt(stmt) }
  lastValue
}

def evalProgram(program: Program): Value / { Exception[RuntimeError], Inspector[Address], Positioning } = {
  with handleRuntimeContext
  with handleDefaultLoopControl
  evalBlock(program)
}