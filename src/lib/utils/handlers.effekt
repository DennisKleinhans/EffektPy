import map
import src/lib/utils/errors
import src/lib/utils/types
import src/lib/utils/effects
import src/lib/utils/helpers

/// Handler for TypingContext effect that manages variable bindings and their types in a mutable map.
def handleTypingContext[R] { prog: => R / Context[TypingType, TypeBinding] }: R / { Exception[NameError], getPos } = {
  var context: Map[String, TypeBinding] = map::emptyGeneric[String, TypeBinding]()

  try { prog() } with Context[TypingType, TypeBinding] {
    def define(name, value, isMutable) = {
      context = context.put(name, TypeBinding(value, isMutable))
      resume(())
    }

    def lookup(name) = {
      context.get(name) match {
        case Some(binding) => resume(binding)
        case None() => {
          val pos = do getPos()
          raise(NameError(), "Undefined variable '" ++ name ++ "' at " ++ pos.show())
        }
      }
    }

    def backup() = resume(context)

    def restore(savedContext) = {
      context = savedContext
      resume(())
    }
  }
}

/// Mock handler for getPos effect that always returns a fixed position (line 1, column 1).
def mockGetPos[R] { prog: => R / getPos } = {
  try { prog() } with getPos {
    def getPos() = resume(Position(1, 1)) // always return line 1, column 1
  }
}

/// Mock handler for Inspector effect that does nothing.
def mockInspector[R] { prog: => R / Inspector[TypeBinding] }: R = {
  try { prog() } with Inspector[TypeBinding] {
    def inspect(context) = resume(())
  }
}

/// Handler that creates a new typing scope for the duration of the action.
def handleNewTypingScope[R]{ action: => R / Context[TypingType, TypeBinding] }: R / Context[TypingType, TypeBinding] = {
  val snapshot = do backup()
  val result = action()
  do restore(snapshot)
  result
}