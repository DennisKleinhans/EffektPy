import map
import src/lib/utils/errors
import src/lib/utils/types
import src/lib/utils/effects
import src/lib/utils/helpers

/// Handler for TypingContext effect that manages variable bindings and their types in a mutable map.
def handleTypingContext[R] { prog: => R / TypingContext }: R / { Exception[NameError], getPos } = {
  var context: Map[String, Binding] = map::emptyGeneric[String, Binding]()

  try { prog() } with TypingContext {
    def define(name, tpe, isMutable) = {
      context = context.put(name, Binding(tpe, isMutable))
      resume(())
    }

    def lookup(name) = {
      context.get(name) match {
        case Some(binding) => resume(binding)
        case None() => {
          val pos = do getPos()
          raise(NameError(), "Undefined variable '" ++ name ++ "' at " ++ pos.show())
        }
      }
    }

    def backup() = resume(context)

    def restore(savedContext) = {
      context = savedContext
      resume(())
    }
  }
}

/// Mock handler for getPos effect that always returns a fixed position (line 1, column 1).
def mockGetPos[R] { prog: => R / getPos } = {
  try { prog() } with getPos {
    def getPos() = resume(Position(1, 1)) // always return line 1, column 1
  }
}

/// Mock handler for Inspector effect that does nothing.
def mockInspector[R] { prog: => R / Inspector }: R = {
  try { prog() } with Inspector {
    def inspect(context) = resume(())
  }
}

/// Handler that creates a new typing scope for the duration of the action.
def handleNewTypingScope[R]{ action: => R / TypingContext }: R / TypingContext = {
  val snapshot = do backup()
  val result = action()
  do restore(snapshot)
  result
}