module src/lib/utils/handlers

import map
import src/lib/utils/errors
import src/lib/utils/effects
import src/lib/utils/helpers
import src/lib/typechecker/types
import src/lib/lexer/position
import src/lib/interpreter/values

/// handler for TypingContext effect that manages variable bindings and their types in a mutable map
def handleTypingContext[R](initialContext: Map[String, TypeBinding]) { prog: => R / Context[TypeBinding] }: R / { Exception[NameError], Positioning } = {
  var context: Map[String, TypeBinding] = initialContext

  try { prog() } with Context[TypeBinding] {
    def define(name, value) = {
      context = context.put(name, value)
      resume(())
    }

    def lookup(name) = {
      context.get(name) match {
        case Some(binding) => resume(binding)
        case None() => {
          raise(NameError(), "Undefined variable '" ++ name ++ "' at " ++ do getPos().show)
        }
      }
    }

    def backup() = resume(context)

    def restore(savedContext) = {
      context = savedContext
      resume(())
    }
  }
}

/// handler for RuntimeContext effect that manages variable bindings and memory store in mutable maps
def handleRuntimeContext[R](initEnv: Map[String, Address]) { prog: => R / { Context[Address] } }: R / {Exception[RuntimeError], Positioning } = {
  var context: Map[String, Address] = initEnv

  try { prog() } with Context[Address] {
    def define(name, addr) = {
      context = context.put(name, addr)
      resume(())
    }

    def lookup(name) = {
      context.get(name) match {
        case Some(addr) => resume(addr)
        case None() => do raise(errors::RuntimeError(), "Undefined variable '" ++ name ++ "' at " ++ do getPos().show)
      }
    }

    def backup() = resume(context)

    def restore(savedContext) = {
      context = savedContext
      resume(())
    }
  } 
}

def handleStore[R](initialData: Map[Address, Value]) { prog: => R / Store }: R / Exception[RuntimeError] = {
  var store: Map[Address, Value] = initialData
  var nextAddress: Address = initialData.size

  try { prog() } with Store {
    def allocate(value) = {
      val addr = nextAddress
      store = store.put(addr, value)
      nextAddress = nextAddress + 1
      resume(addr)
    }

    def load(addr) = store.get(addr) match {
      case Some(value) => resume(value)
      case None() => do raise(errors::RuntimeError(), "Invalid memory access at address " ++ addr.show)
    }

    def store(addr, value) = {
      store = store.put(addr, value)
      resume(())
    }

    def dump() = resume(store)
  }
} 


/// mock handler for Positioning effect that always returns a fixed position (line 1, column 1)
def mockGetPos[R] { prog: => R / Positioning } = {
  try { prog() } with Positioning {
    def getPos() = resume(Position(0, 0)) // always return line 0, column 0
    def setPos(p) = resume(())
  }
}

/// mock handler for Inspector effect that does nothing
def mockInspector[R, T] { prog: => R / Inspector[T] }: R = {
  try { prog() } with Inspector[T] {
    def inspect(context) = resume(())
  }
}

/// handler that creates a new typing scope for the duration of the action
def handleNewTypingScope[R]{ action: => R / Context[TypeBinding] }: R / Context[TypeBinding] = {
  val snapshot = do backup()
  val result = action()
  do restore(snapshot)
  result
}

/// handler that creates a new runtime scope for the duration of the action
def handleNewRuntimeScope[R]{ action: => R / Context[Address] }: R / Context[Address] = {
  val snapshot = do backup()
  val result = action()
  do restore(snapshot)
  result
}

/// executes a block of code at a specific source code position
def at[R](p: Position) { block: => R / Positioning }: R / Positioning = {
  val old = do getPos()
  do setPos(p)
  val res = block()
  do setPos(old)
  res
}

/// Handler for LoopControl effect that raises an error when break/continue is used outside a loop.
/// This should never happen, because the typesystem avoids the usage of break/continue outside loops.
def handleDefaultLoopControl[R] { action: => R / LoopControl}: R / Exception[RuntimeError] = {
  try { action() } with LoopControl {
    def breakLoop() = raise(errors::RuntimeError(), "break statement not within a loop")
    def continueLoop() = raise(errors::RuntimeError(), "continue statement not within a loop")
  }
} 

/// Handler for the console effect, using the Console available in js. Supports a additional writeSingle method for REPL prompts.
def consoleRepl[R] { program: () => R / REPLConsole }: R = {
  val c = js::newConsole()
  try {
    val r = program()
    js::close(c)
    return r
  } with REPLConsole {
    def readLine() = resume(js::readLine(c))
    def writeLine(message) = resume(js::writeLine(c, message))
    def writeSingle(message) = resume(js::write(c, message))
  } 
}